<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A bursty model with delay · DelaySSAToolkit.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://palmtree2013.github.io/DelaySSAToolkit.jl/tutorials/bursty/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaySSAToolkit.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li class="is-active"><a class="tocitem" href>A bursty model with delay</a><ul class="internal"><li><a class="tocitem" href="#Model"><span>Model</span></a></li><li><a class="tocitem" href="#Markovian-part"><span>Markovian part</span></a></li><li><a class="tocitem" href="#Non-Markovian-part"><span>Non-Markovian part</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../delay_degradation/">A birth-death example with delay degradation</a></li><li><a class="tocitem" href="../heterogeneous_delay/">A birth-death model with heterogeneous fixed delays</a></li><li><a class="tocitem" href="../delay_oscillator/">An auto-regulatory model of oscillatory gene expression</a></li><li><a class="tocitem" href="../stochastic_delay/">A telegraph model of stochastic delay</a></li></ul></li><li><span class="tocitem">Algorithm</span><ul><li><a class="tocitem" href="../../algorithms/notations/">Notations and Basic Concepts</a></li><li><a class="tocitem" href="../../algorithms/delayrejection/">Delay Rejection Method Algorithm</a></li><li><a class="tocitem" href="../../algorithms/delaydirect/">Delay Direct Method Algorithm</a></li><li><a class="tocitem" href="../../algorithms/delaymnrm/">Delay Modified Next Reaction Method Algorithm</a></li></ul></li><li><a class="tocitem" href="../../theory/">Theory</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>A bursty model with delay</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A bursty model with delay</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/palmtree2013/DelaySSAToolkit.jl/blob/main/docs/src/tutorials/bursty.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="bursty_model"><a class="docs-heading-anchor" href="#bursty_model">A bursty model with delay</a><a id="bursty_model-1"></a><a class="docs-heading-anchor-permalink" href="#bursty_model" title="Permalink"></a></h1><h2 id="Model"><a class="docs-heading-anchor" href="#Model">Model</a><a id="Model-1"></a><a class="docs-heading-anchor-permalink" href="#Model" title="Permalink"></a></h2><p>We study the following gene expression model which does not have an explicit gene state description and that the product (mRNA or protein denoted as P) is actively transcribed in bursts whose size are distributed according to a geometric distribution. This means the propensity function is given by <span>$f(n) = ab^n/(1+b)^{n+1}$</span> for any positive integer <span>$n$</span>. The bursty model can be summarized by the reactions:</p><p class="math-container">\[\frac{ab^n}{(1+b)^{n+1}}: \emptyset \rightarrow nP \text{ triggers }nP\Rightarrow\emptyset \text{ after $\tau$ time.}\]</p><h2 id="Markovian-part"><a class="docs-heading-anchor" href="#Markovian-part">Markovian part</a><a id="Markovian-part-1"></a><a class="docs-heading-anchor-permalink" href="#Markovian-part" title="Permalink"></a></h2><p>The system has an explicit solution which is obtained in [1, Supplementary Note Section 2]. We first construct the reaction network</p><pre><code class="language-julia hljs">@parameters a b t
@variables X(t)
burst_sup = 30
rxs = [Reaction(ab^n / (1 + b)^{n + 1}, nothing, [X], nothing, [n]) for n in 1:burst_sup]
rxs = vcat(rxs)
@named rs = ReactionSystem(rxs, t, [X], [a, b])</code></pre><p>In the example, we set <span>$a=0.0282$</span> and <span>$b=3.46$</span> and set the upper bound of the burst size as <code>burst_sup = 30</code>. This means we ignore all the reactions <span>$ab^n/(1+b)^{n+1}:\emptyset \rightarrow nP$</span> for any <span>$n &gt; 30$</span> where the reaction rate <span>$ab^n/(1+b)^{n+1} \sim 10^{-6}$</span>. We first convert the <code>ReactionSystem</code> to a <code>JumpSystem</code> and initialize the discrete problem by</p><pre><code class="language-julia hljs">jumpsys = convert(JumpSystem, rs; combinatoric_ratelaws=false)
u0 = [0]
tf = 200.0
tspan = (0, tf)
timestamp = 0:1:tf
ps = [0.0282, 3.46]
τ = 130.0
dprob = DiscreteProblem(jumpsys, u0, tspan, ps)</code></pre><h2 id="Non-Markovian-part"><a class="docs-heading-anchor" href="#Non-Markovian-part">Non-Markovian part</a><a id="Non-Markovian-part-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Markovian-part" title="Permalink"></a></h2><p>Next, we define the non-Markovian part. Here we mainly need to consider the delay trigger reactions that are, for <em>n</em>th-reaction, <span>$\emptyset \rightarrow nP$</span>, the delay channel will be added of a vector <span>$[\tau,\ldots,\tau]$</span> of size <span>$n$</span>. Thus, we have</p><pre><code class="language-julia hljs">delay_trigger_affect! = []
for n in 1:burst_sup
    push!(delay_trigger_affect!, function (integrator, rng)
        return append!(integrator.de_chan[1], fill(τ, n))
    end)
end
delay_trigger = Dict([Pair(i, delay_trigger_affect![i]) for i in 1:burst_sup])
delay_interrupt = Dict()
delay_complete = Dict(1 =&gt; [1 =&gt; -1])
delayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)</code></pre><ul><li><p><code>delay_trigger</code></p><ul><li>Keys: Indices of reactions defined in <code>jumpset</code> that can trigger the delay reaction.  For each <span>$n= 1,\ldots,30,$</span> the reaction <span>$ab^n/(1+b)^{n+1}:\emptyset \rightarrow nP$</span>, that will trigger <span>$nP$</span> to degrade after time <span>$\tau$</span>.</li><li>Values: An update function that determines how to update the delay channel. In this example, once the delay reaction is triggered to the delay channel (which is the channel for <span>$P$</span>), the latter will be added an array of delay time <span>$\tau$</span> depending on the bursting number <span>$n$</span>.</li></ul></li><li><p><code>delay_interrupt</code></p><ul><li>There are no delay interrupt reactions in this example, so we set <code>delay_interrupt = Dict()</code>.</li></ul></li><li><p><code>delay_complete</code></p><ul><li>Keys: Indices of delay channel. Here we only have one delay channel for <span>$P$</span>.</li><li>Values: A vector of <code>Pair</code>s, mapping species index to net change of stoichiometric coefficient. Here the degradation will cause the first species to have a net change of <span>$-1$</span>. In this example, one might have <span>$nP$</span> leaving the system simultaneously. Such multiple delay reactions are taken care of automatically by the delay SSA algorithm.</li></ul></li></ul><p>We define the delay jump problem by</p><pre><code class="language-julia hljs">de_chan0 = [[]]
jprob = DelayJumpProblem(
    jumpsys, dprob, DelayRejection(), delayjumpset, de_chan0; save_positions=(false, false)
)</code></pre><p>where <code>de_chan0</code> is the initial condition for the delay channel where we assume no ongoing delay reactions at <span>$t=0$</span>. <code>DelayJumpProblem</code> inputs <code>JumpSystem</code>, <code>DelayJumpProblem</code>, <code>DelayJumpSet</code>, the algorithm and the initial condition of the delay channel <code>de_chan0</code>.</p><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><pre><code class="language-julia hljs">ensprob = EnsembleProblem(jprob)
@time ens = solve(ensprob, SSAStepper(), EnsembleThreads(); trajectories=10^5)</code></pre><p>We compare the distribution computed using the delay SSA and the exact solution, finding excellent agreement. <img src="../../assets/bursty.svg" alt="bursty"/></p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] Qingchao Jiang, Xiaoming Fu, Shifu Yan, Runlai Li, Wenli Du, Zhixing Cao, Feng Qian, Ramon Grima, &quot;Neural network aided approximation and parameter inference of non-Markovian models of gene expression&quot;. Nature communications, (2021) 12(1), 1-12. <a href="https://doi.org/10.1038/s41467-021-22919-1">https://doi.org/10.1038/s41467-021-22919-1</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/">« Tutorials</a><a class="docs-footer-nextpage" href="../delay_degradation/">A birth-death example with delay degradation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 9 August 2023 09:23">Wednesday 9 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
