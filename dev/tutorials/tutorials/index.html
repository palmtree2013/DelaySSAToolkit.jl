<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorials · DelaySSAToolkit.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://palmtree2013.github.io/DelaySSAToolkit.jl/tutorials/tutorials/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaySSAToolkit.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Tutorials</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Model"><span>Model</span></a></li><li><a class="tocitem" href="#First-route:-JumpSystem-DiscreteProblem-DelayJumpSet"><span>First route: <code>JumpSystem + DiscreteProblem + DelayJumpSet</code></span></a></li><li><a class="tocitem" href="#second_route"><span>Second route: <code>JumpSet + DiscreteProblem + DelayJumpSet</code></span></a></li></ul></li><li><a class="tocitem" href="../bursty/">A bursty model with delay</a></li><li><a class="tocitem" href="../delay_degradation/">A birth-death example with delay degradation</a></li><li><a class="tocitem" href="../heterogeneous_delay/">A birth-death model with heterogeneous fixed delays</a></li><li><a class="tocitem" href="../delay_oscillator/">An auto-regulatory model of oscillatory gene expression</a></li><li><a class="tocitem" href="../stochastic_delay/">A telegraph model of stochastic delay</a></li></ul></li><li><span class="tocitem">Algorithm</span><ul><li><a class="tocitem" href="../../algorithms/notations/">Notations and Basic Concepts</a></li><li><a class="tocitem" href="../../algorithms/delayrejection/">Delay Rejection Method Algorithm</a></li><li><a class="tocitem" href="../../algorithms/delaydirect/">Delay Direct Method Algorithm</a></li><li><a class="tocitem" href="../../algorithms/delaymnrm/">Delay Modified Next Reaction Method Algorithm</a></li></ul></li><li><a class="tocitem" href="../../theory/">Theory</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Tutorials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorials</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/palmtree2013/DelaySSAToolkit.jl/blob/main/docs/src/tutorials/tutorials.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="seir_model"><a class="docs-heading-anchor" href="#seir_model">Tutorials</a><a id="seir_model-1"></a><a class="docs-heading-anchor-permalink" href="#seir_model" title="Permalink"></a></h1><p>This tutorial aims to explain how to use DelaySSAToolkit to define chemical reaction models, solve the problems and visualize the results. The source code of all the examples and figures is available in the GitHub examples folder. To demonstrate these functionalities, we will consider a specific case from epidemic modelling as follows</p><p class="math-container">\[S+I\xrightarrow{\rho}E+I,\\
I\stackrel{r}{\rightarrow}R.\]</p><p>Notice that <span>$S+I\xrightarrow{\rho} E+I$</span> will trigger <span>$E\Rightarrow I$</span> after <span>$\tau$</span> time, where <span>$S$</span>, <span>$E$</span>, <span>$I$</span> and <span>$R$</span> are the susceptible, exposed, infected and recovered populations.  This means, with rate <span>$\rho$</span>, a susceptible contacted by an infected will immediately become an individual that is exposed to the disease, and then it takes a certain amount of time delay <span>$\tau$</span> to become an infected individual.</p><h1 id="Model"><a class="docs-heading-anchor" href="#Model">Model</a><a id="Model-1"></a><a class="docs-heading-anchor-permalink" href="#Model" title="Permalink"></a></h1><p>For the non-Markovian model, what differs from the Markovian model is the introduction of <strong>delay reactions</strong>. To show how we incorporate the delay reactions into the Markovian system, we first need to define the Markovian part and then its non-Markovian part. These two parts mainly form a <code>DelayJumpProblem</code>. Here we show two routes to define our delay system, one way is based on <code>JumpSystem</code>, <code>DiscreteProblem</code> and <code>DelayJumpSet</code>, and the other is based on <code>JumpSet</code>, <code>DiscreteProblem</code> and <code>DelayJumpSet</code>.</p><h2 id="First-route:-JumpSystem-DiscreteProblem-DelayJumpSet"><a class="docs-heading-anchor" href="#First-route:-JumpSystem-DiscreteProblem-DelayJumpSet">First route: <code>JumpSystem + DiscreteProblem + DelayJumpSet</code></a><a id="First-route:-JumpSystem-DiscreteProblem-DelayJumpSet-1"></a><a class="docs-heading-anchor-permalink" href="#First-route:-JumpSystem-DiscreteProblem-DelayJumpSet" title="Permalink"></a></h2><h3 id="Markovian_part"><a class="docs-heading-anchor" href="#Markovian_part">Markovian part</a><a id="Markovian_part-1"></a><a class="docs-heading-anchor-permalink" href="#Markovian_part" title="Permalink"></a></h3><p><a href="https://github.com/SciML/Catalyst.jl">Catalyst.jl</a> provides a comprehensive interface to model reaction networks in Julia and can be used to construct models fully-compatible with DelaySSAToolkit. For more details on how to construct a reaction network, we recommend reading <a href="https://catalyst.sciml.ai/stable/tutorials/using_catalyst/">Catalyst&#39;s tutorial</a>. In our example, the Markovian part (<strong>model without delays</strong>) of the model can be defined as:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    ρ, S+I --&gt; E+I
    r, I --&gt; R
end ρ r</code></pre><p>We can easily obtain a <code>Jumpsystem</code> from the reaction network <code>rn</code>.</p><pre><code class="language-julia hljs">jumpsys = convert(JumpSystem, rn, combinatoric_ratelaws=false)</code></pre><p>where <code>combinatoric_ratelaws</code> is an optional parameter that specifies whether the rate constants correspond to stochastic rate constants in the sense used by Gillespie [1]. By default, the rates are rescaled. This means that for a reaction such as <span>$2A \overset{k}{\rightarrow} B$</span>, the jump rate function would be <span>$kA(A-1)/2!$</span>. To <strong>avoid</strong> having the reaction rates rescaled (by <span>$1/2$</span> for this example), one can pass the constructor the optional named parameter <code>combinatoric_ratelaws=false</code> (see <a href="https://catalyst.sciml.ai/stable/tutorials/using_catalyst/#Reaction-rate-laws-used-in-simulations">reaction rate laws used in simulations</a> for details).</p><p>With the initial conditions, we can then define <code>DiscreteProblem</code></p><pre><code class="language-julia hljs">u0 = [999,1,0,0] # S, I, E, R
tf = 400.
tspan = (0,tf)
ps = [1e-4, 1e-2] # parameters for ρ, r
τ = 20.
dprob = DiscreteProblem(jumpsys,u0,tspan,ps)</code></pre><p>where <code>DiscreteProblem</code> has inputs as the jump system <code>jumpsys</code>, the initial condition of reactants <code>u0</code>, the simulation timespan <code>tspan</code> and the reaction rates <code>ps</code>. </p><h3 id="Non-Markovian-part"><a class="docs-heading-anchor" href="#Non-Markovian-part">Non-Markovian part</a><a id="Non-Markovian-part-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Markovian-part" title="Permalink"></a></h3><p>The non-Markovian part mainly consists of three parts:</p><ul><li>delay trigger reactions: those reactions in the <a href="#Markovian_part">Markovian part</a> that trigger the change of the delay channels or/and the state of the reactants upon initiation.</li><li>delay interrupt reactions: those reactions in the <a href="#Markovian_part">Markovian part</a> that change the delay channels or/and the state of the reactants in the middle of ongoing delay reactions.</li><li>delay complete reactions: those reactions that are initiated by delay trigger reactions and change the delay channels or/and the state of the reactants upon completion.</li></ul><p>With these three definitions in mind and based on this particular example, we define the <code>DelayJumpSet</code> by</p><pre><code class="language-julia hljs">delay_trigger_affect! = function (integrator, rng)
    append!(integrator.de_chan[1], τ)
end
delay_trigger = Dict(1=&gt;delay_trigger_affect!)
delay_interrupt = Dict()
delay_complete = Dict(1=&gt;[2=&gt;1, 3=&gt;-1])
delayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)</code></pre><ul><li><code>delay_trigger::Dict</code>  A dictionary that contains<ul><li><p>Keys: Indices of reactions defined in the <a href="#Markovian_part">Markovian part</a> that can trigger delay reactions (see <a href="#Remark">Remark</a> on the reaction indices). Here we have the first reaction <span>$S+I\Rightarrow E+ I$</span> (represented by <code>delay_trigger = Dict(1=&gt;...)</code>) that will trigger the transfer from <span>$E$</span> to <span>$I$</span> after time <span>$\tau$</span>.</p></li><li><p>Values: An update function that determines how to update the delay channel. In this example, once the delay reaction is triggered, the first delay channel will be added a delay time <span>$\tau$</span>. The update function has two inputs: 1. <code>integrator</code>: which stores the current state of the reactants (<code>integrator.u</code>) and the delay channels (<code>integrator.de_chan</code>); 2. <code>rng</code>: the random seed for a given stochastic simulation.</p></li></ul></li><li><code>delay_interrupt::Dict</code><ul><li>There are no delay interrupt reactions in this example, so we set <code>delay_interrupt = Dict()</code>.</li></ul></li><li><code>delay_complete::Dict</code> <ul><li>Keys: Indices of delay channels. Here we only have one delay channel.</li><li>Values: A vector of <code>Pair</code>s, mapping species index to net change of stoichiometric coefficient. Here once the delay reaction is completed, the third species <em>E</em> is transferred to the second <em>I</em>, thus the net change of the second species is <span>$1$</span> and the third <span>$-1$</span>. For the details about the order of the species see <a href="tutorials/@id Remark">Remark</a>.</li></ul></li></ul><p>We refer to <a href="tutorials/bursty.md/#Defining-a-DelayJumpSet">Defining a <code>DelayJumpSet</code> (bursty model)</a> and <a href="tutorials/delay_degradation.md/#Defining-a-DelayJumpSet">Defining a <code>DelayJumpSet</code>(birth-death model)</a> for more details.</p><p>Now we can define the <code>DelayJumpProblem</code> by </p><pre><code class="language-julia hljs">de_chan0 = [[]]
djprob = DelayJumpProblem(jumpsys, dprob, DelayRejection(), delayjumpset, de_chan0, save_positions=(true,true))</code></pre><p>where <code>DelayJumpProblem</code> inputs <code>jumpsys</code>,<code>DiscreteProblem</code>, <code>DelayJumpSet</code>, the algorithm and the initial condition of the delay channel <code>de_chan0</code>.  Here <code>de_chan0</code> is the initial condition for the delay channel, which is a vector of arrays whose <em>k</em>th entry stores the scheduled delay time for <em>k</em>th delay channel. Here the only delay channel is for exposed population, and we assume <span>$E(0) = 0$</span>.  The optional keyword argument <code>save_positions</code> is a Boolean tuple for whether to save before and after the event. Then one can use </p><pre><code class="language-julia hljs">sol = solve(djprob, SSAStepper())</code></pre><p>to solve the problem.</p><h2 id="second_route"><a class="docs-heading-anchor" href="#second_route">Second route: <code>JumpSet + DiscreteProblem + DelayJumpSet</code></a><a id="second_route-1"></a><a class="docs-heading-anchor-permalink" href="#second_route" title="Permalink"></a></h2><p>Now we explain how to define the <code>DelayJumpProblem</code> in another way. To that aim, we first define the parameters and the mass-action jump (see <a href="https://diffeq.sciml.ai/stable/types/jump_types/#Defining-a-Mass-Action-Jump">Defining a Mass Action Jump</a> for details) and construct a <code>Jumpset</code>.</p><h3 id="Markovian-part"><a class="docs-heading-anchor" href="#Markovian-part">Markovian part</a><a id="Markovian-part-1"></a><a class="docs-heading-anchor-permalink" href="#Markovian-part" title="Permalink"></a></h3><pre><code class="language-julia hljs">ρ, r = [1e-4, 1e-2]
rates = [ρ, r]
reactant_stoich = [[1=&gt;1,2=&gt;1],[2=&gt;1]]
net_stoich = [[1=&gt;-1,3=&gt;1],[2=&gt;-1,4=&gt;1]]
mass_jump = MassActionJump(rates, reactant_stoich, net_stoich; scale_rates =false)
jumpset = JumpSet((),(),nothing,mass_jump)</code></pre><p>We briefly explain the notations here:</p><ul><li><code>rates</code> is a vector of rates of reactions.</li><li><code>reactant_stoich</code> is a vector whose <code>k</code>th entry is the reactant stoichiometry of the <code>k</code>th reaction. The reactant stoichiometry for an individual reaction is assumed to be represented as a vector of <code>Pair</code>s, mapping species index to stoichiometric coefficient.</li><li><code>net_stoich</code> is assumed to have the same type as <code>reactant_stoich</code>; a vector whose <code>k</code>th entry is the net stoichiometry of the <code>k</code>th reaction. The net stoichiometry for an individual reaction is again represented as a vector of <code>Pair</code>s, mapping species index to the net change in the species when the reaction occurs.</li><li><code>scale_rates</code> is an optional parameter that specifies whether the rate constants correspond to stochastic rate constants in the sense used by Gillespie. This has the same functionality as <code>combinatoric_ratelaws</code> in the conversion to a <code>JumpSystem</code> (see <a href="#Markovian_part">Markovian part</a>).</li></ul><p>The <code>JumpSet</code> consists of four inputs, namely variable jumps, constant rate jumps, regular jumps and mass-action jumps. As far as discrete stochastic simulation is concerned, we only focus on constant rate jumps and mass-action jumps which are the second and fourth entries of <code>JumpSet</code> (see <a href="https://diffeq.sciml.ai/stable/types/jump_types/">different jump types</a>). Here we only have two mass-action jumps that are wrapped in <code>mass_jump</code>. Then we initialize the problem by setting</p><pre><code class="language-julia hljs">u0 = [999,1,0,0]
de_chan0 = [[]]
tf = 400.
tspan = (0,tf)
τ = 20.</code></pre><p>As before, we can define the <code>DiscreteProblem</code></p><pre><code class="language-Julia hljs">dprob = DiscreteProblem(u0, tspan)</code></pre><h3 id="Non-Markovian-part-2"><a class="docs-heading-anchor" href="#Non-Markovian-part-2">Non-Markovian part</a><a class="docs-heading-anchor-permalink" href="#Non-Markovian-part-2" title="Permalink"></a></h3><p>In the same way, we can define the  <code>DelayJumpSet</code> by</p><pre><code class="language-julia hljs">delay_trigger_affect! = function (integrator, rng)
    append!(integrator.de_chan[1], τ)
end
delay_trigger = Dict(1=&gt;delay_trigger_affect!)
delay_complete = Dict(1=&gt;[2=&gt;1, 3=&gt;-1])
delay_interrupt = Dict()
delayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)</code></pre><p>Now we can define the problem</p><pre><code class="language-julia hljs">djprob = DelayJumpProblem(dprob, DelayRejection(), jumpset, delayjumpset, de_chan0, save_positions=(true,true)).</code></pre><p>At last, we can solve the problem and visualize it</p><pre><code class="language-julia hljs">sol = solve(djprob, SSAStepper())</code></pre><p><img src="../../assets/seir.svg" alt="seir"/></p><h3 id="Remark"><a class="docs-heading-anchor" href="#Remark">Remark</a><a id="Remark-1"></a><a class="docs-heading-anchor-permalink" href="#Remark" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To check the order of the species in a reaction network <code>rn::ReactionSystem</code> (or a <code>jumpsys::JumpSystem</code>), one can call <code>species(rn)</code> (or <code>states(jumpsys)</code> respectively). Converting a <code>ReactionSystem</code> defined by Catalyst into a <code>JumpSystem</code> might change the order of the reactions that is in your original reaction network. Internally, all MassActionJumps are ordered before ConstantRateJumps (with the latter internally ordered in the same order they were passed in). The same principle applies for the construction of a <code>JumpSet</code>.  </p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../bursty/">A bursty model with delay »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Thursday 30 June 2022 03:44">Thursday 30 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
