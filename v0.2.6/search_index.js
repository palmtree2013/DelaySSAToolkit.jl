var documenterSearchIndex = {"docs":
[{"location":"tutorials/bursty/#bursty_model","page":"A bursty model with delay","title":"A bursty model with delay","text":"","category":"section"},{"location":"tutorials/bursty/#Model","page":"A bursty model with delay","title":"Model","text":"","category":"section"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"We study the following gene expression model which does not have an explicit gene state description and that the product (mRNA or protein denoted as P) is actively transcribed in bursts whose size are distributed according to a geometric distribution. This means the propensity function is given by f(n) = ab^n(1+b)^n+1 for any positive integer n. The bursty model can be summarized by the reactions:","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"fracab^n(1+b)^n+1 emptyset rightarrow nP text triggers nPRightarrowemptyset text after tau time","category":"page"},{"location":"tutorials/bursty/#Markovian-part","page":"A bursty model with delay","title":"Markovian part","text":"","category":"section"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"The system has an explicit solution which is obtained in [1, Supplementary Note Section 2]. We first construct the reaction network","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"@parameters a b t\n@variables X(t)\nburst_sup = 30\nrxs = [Reaction(ab^n / (1 + b)^{n + 1}, nothing, [X], nothing, [n]) for n in 1:burst_sup]\nrxs = vcat(rxs)\n@named rs = ReactionSystem(rxs, t, [X], [a, b])","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"In the example, we set a=00282 and b=346 and set the upper bound of the burst size as burst_sup = 30. This means we ignore all the reactions ab^n(1+b)^n+1emptyset rightarrow nP for any n  30 where the reaction rate ab^n(1+b)^n+1 sim 10^-6. We first convert the ReactionSystem to a JumpSystem and initialize the discrete problem by","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"jumpsys = convert(JumpSystem, rs; combinatoric_ratelaws=false)\nu0 = [0]\ntf = 200.0\ntspan = (0, tf)\ntimestamp = 0:1:tf\nps = [0.0282, 3.46]\nτ = 130.0\ndprob = DiscreteProblem(jumpsys, u0, tspan, ps)","category":"page"},{"location":"tutorials/bursty/#Non-Markovian-part","page":"A bursty model with delay","title":"Non-Markovian part","text":"","category":"section"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"Next, we define the non-Markovian part. Here we mainly need to consider the delay trigger reactions that are, for nth-reaction, emptyset rightarrow nP, the delay channel will be added of a vector tauldotstau of size n. Thus, we have","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"delay_trigger_affect! = []\nfor n in 1:burst_sup\n    push!(delay_trigger_affect!, function (integrator, rng)\n        return append!(integrator.de_chan[1], fill(τ, n))\n    end)\nend\ndelay_trigger = Dict([Pair(i, delay_trigger_affect![i]) for i in 1:burst_sup])\ndelay_interrupt = Dict()\ndelay_complete = Dict(1 => [1 => -1])\ndelayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"delay_trigger\nKeys: Indices of reactions defined in jumpset that can trigger the delay reaction.  For each n= 1ldots30 the reaction ab^n(1+b)^n+1emptyset rightarrow nP, that will trigger nP to degrade after time tau.\nValues: An update function that determines how to update the delay channel. In this example, once the delay reaction is triggered to the delay channel (which is the channel for P), the latter will be added an array of delay time tau depending on the bursting number n.\ndelay_interrupt\nThere are no delay interrupt reactions in this example, so we set delay_interrupt = Dict().\ndelay_complete\nKeys: Indices of delay channel. Here we only have one delay channel for P.\nValues: A vector of Pairs, mapping species index to net change of stoichiometric coefficient. Here the degradation will cause the first species to have a net change of -1. In this example, one might have nP leaving the system simultaneously. Such multiple delay reactions are taken care of automatically by the delay SSA algorithm.","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"We define the delay jump problem by","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"de_chan0 = [[]]\njprob = DelayJumpProblem(\n    jumpsys, dprob, DelayRejection(), delayjumpset, de_chan0; save_positions=(false, false)\n)","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"where de_chan0 is the initial condition for the delay channel where we assume no ongoing delay reactions at t=0. DelayJumpProblem inputs JumpSystem, DelayJumpProblem, DelayJumpSet, the algorithm and the initial condition of the delay channel de_chan0.","category":"page"},{"location":"tutorials/bursty/#Visualization","page":"A bursty model with delay","title":"Visualization","text":"","category":"section"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"ensprob = EnsembleProblem(jprob)\n@time ens = solve(ensprob, SSAStepper(), EnsembleThreads(); trajectories=10^5)","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"We compare the distribution computed using the delay SSA and the exact solution, finding excellent agreement. (Image: bursty)","category":"page"},{"location":"tutorials/bursty/#References","page":"A bursty model with delay","title":"References","text":"","category":"section"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"[1] Qingchao Jiang, Xiaoming Fu, Shifu Yan, Runlai Li, Wenli Du, Zhixing Cao, Feng Qian, Ramon Grima, \"Neural network aided approximation and parameter inference of non-Markovian models of gene expression\". Nature communications, (2021) 12(1), 1-12. https://doi.org/10.1038/s41467-021-22919-1","category":"page"},{"location":"tutorials/stochastic_delay/#A-telegraph-model-of-stochastic-delay","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"","category":"section"},{"location":"tutorials/stochastic_delay/#Model","page":"A telegraph model of stochastic delay","title":"Model","text":"","category":"section"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"According to [1], a telegraph gene expression model with stochastic delay assumes that the gene can switch between active G and inactive G^* states, transcribes nascent mRNA (denoted by N) while in the active state which subsequently is removed a time tau later. Here the delay tau can be a random variable. The reaction scheme is given by","category":"page"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"G^*xrightarrowk_texton G\nGxrightarrowk_textoffG^*\nGxrightarrowrhoG+N","category":"page"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"Note that GxrightarrowrhoG+N will trigger NRightarrow emptyset after a delay time tau. We set k_texton=00282, k_textoff=0609 and rho=211.","category":"page"},{"location":"tutorials/stochastic_delay/#Markovian-part","page":"A telegraph model of stochastic delay","title":"Markovian part","text":"","category":"section"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"We first define the model using Catalyst (see this example for more details about the construction of a reaction network).","category":"page"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"using Catalyst, DelaySSAToolkit\nusing Random, Distributions\nrn = @reaction_network begin\n    kon, Goff --> Gon\n    koff, Gon --> Goff\n    ρ, Gon --> Gon + N\nend\njumpsys = convert(JumpSystem, rn; combinatoric_ratelaws=false)","category":"page"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"Then we set the Initial value and define a DiscreteProblem.","category":"page"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"u0 = [1, 0, 0] # Gon, Goff, N\ntf = 2000.0\ntspan = (0.0, tf)\ndprob = DiscreteProblem(u0, tspan)","category":"page"},{"location":"tutorials/stochastic_delay/#Non-Markovian-part","page":"A telegraph model of stochastic delay","title":"Non-Markovian part","text":"","category":"section"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"Unlike other examples, the elongation time tau is a random variable sampled from two different Log Normal distributions. We assume tausim textLogNormal(02)+120 and tausim textLogNormal(1sqrt2)+120. For instance, we take tausim textLogNormal(1sqrt2)+120 and define","category":"page"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"delay_trigger_affect! = function (integrator, rng)\n    τ = rand(LogNormal(1, sqrt(2))) + 120\n    return append!(integrator.de_chan[1], τ)\nend\ndelay_trigger = Dict(3 => delay_trigger_affect!)\ndelay_complete = Dict(1 => [3 => -1])\ndelay_interrupt = Dict()\ndelayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)","category":"page"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"To see how to define the DelayJumpSet, we refer to this example. Thus, we can define the problem","category":"page"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"de_chan0 = [[]]\ndjprob = DelayJumpProblem(\n    jumpsys, dprob, DelayRejection(), delayjumpset, de_chan0; save_positions=(false, false)\n)","category":"page"},{"location":"tutorials/stochastic_delay/#Visualisation","page":"A telegraph model of stochastic delay","title":"Visualisation","text":"","category":"section"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"We simulate 10^5 trajectories and calculate the probability distribution.","category":"page"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"ensprob = EnsembleProblem(djprob)\n@time ens = solve(ensprob, SSAStepper(), EnsembleThreads(); trajectories=10^5)","category":"page"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"(Image: stochastic_delay1)","category":"page"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"If we change the stochastic delay to tausim textLogNormal(02)+120, we can see the zero-inflated mode disappeared. (Image: stochastic_delay2)","category":"page"},{"location":"tutorials/stochastic_delay/#References","page":"A telegraph model of stochastic delay","title":"References","text":"","category":"section"},{"location":"tutorials/stochastic_delay/","page":"A telegraph model of stochastic delay","title":"A telegraph model of stochastic delay","text":"[1] Qingchao Jiang, Xiaoming Fu, Shifu Yan, Runlai Li, Wenli Du, Zhixing Cao, Feng Qian, Ramon Grima, \"Neural network aided approximation and parameter inference of non-Markovian models of gene expression\". Nature communications, (2021) 12(1), 1-12. https://doi.org/10.1038/s41467-021-22919-1","category":"page"},{"location":"algorithms/delayrejection/#Delay-Rejection-Method-Algorithm","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"","category":"section"},{"location":"algorithms/delayrejection/","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"Simulation methods for systems with delays need to calculate when reactions initiate and store when they complete. However, because of the delayed reactions, the propensity functions can change between initiation times. Bratsun et al. [1] and Barrio et al. [2] used an algorithm for computing the initiation times that is exactly like the original Gillespie Algorithm except that if there is a stored delayed reaction set to finish within a computed time step, then the computed time step is discarded, and the system is updated to incorporate the stored delayed reaction. The algorithm then attempts another step starting at its new state. This algorithm is called the Rejection Method.","category":"page"},{"location":"algorithms/delayrejection/#Algorithm","page":"Delay Rejection Method Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"algorithms/delayrejection/","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"Initialize. Set the initial number of molecules of each species and set t = 0.\nCalculate the propensity function, a_k, for each reaction.\nSet a_0 = sum_k=1^M a_k.\nGenerate an independent uniform (01) random number, r_1, and set Delta = 1a_0 ln(1r_1).\nIf there is a delayed reaction set to finish in t t + Delta)\nDiscard Delta.\nUpdate t to be the time of the next delayed reaction,mu.\nUpdate mathbfx according to the stored reaction mu.\nElse\nGenerate an independent uniform (01) random number r_2.\nFind muin1ldots m such that\nsum_k=1^mu-1 a_k(t)  r_2 a_0 leq sum_k=1^mu a_k(t)\nIf muin textND, update the number of each molecular species according to reaction mu.\nIf muin textCD, store the information that at time t+tau_mu the system must be updated according to reaction mu.\nIf muin textICD, update the system according to the initiation of mu and store that at time t+tau_mu the system must be updated according to the completion of reaction mu.\nSet t = t +Delta\nEndif\nReturn to step 2 or quit.","category":"page"},{"location":"algorithms/delayrejection/#References","page":"Delay Rejection Method Algorithm","title":"References","text":"","category":"section"},{"location":"algorithms/delayrejection/","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"[1] Dmitri A. Bratsun, Dmitri N. Volfson, Jeff Hasty, and Lev S. Tsimring \"Non-Markovian processes in gene regulation (Keynote Address)\", Proc. SPIE 5845, Noise in Complex Systems and Stochastic Dynamics III, (23 May 2005). https://doi.org/10.1117/12.609707","category":"page"},{"location":"algorithms/delayrejection/","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"[2]  Manuel Barrio, Kevin Burrage, André Leier, Tianhai Tian. \"Oscillatory Regulation of Hes1: Discrete Stochastic Delay Modelling and Simulation\", PLoS Computational Biology, 10.1371(2006). https://doi.org/10.1371/journal.pcbi.0020117","category":"page"},{"location":"algorithms/notations/#Notations-and-Basic-Concepts","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"","category":"section"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"DelaySSAToolkit now supports four exact delay stochastic simulation algorithms, namely, delay rejection method DelayRejction [1,2], delay direct method DelayDirect [3], delay modified next reaction method DelayMNRM [4] and delay direct method with composition and rejection DelayDirectCR [5,6], which intend to solve reaction systems with different scales with the best performance. We refer to recommendation for details. We point out that delay direct method with composition and rejection achieves better computational efficiency by a more complex underlying data structure and a partition of propensity functions (see [5-6] for more details), and the fundamental algorithm structure remains the same as delay rejection method. Here we briefly present the algorithm structures of the delay rejection method, delay direct method and delay modified next reaction method. First, we introduce some basic concepts for delay stochastic simulation algorithms.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"Consider a system consisting of N geq 1 chemical species, X_1ldots X_N, undergoing M geq 1 chemical reactions through reaction channels R_1ldotsR_M, each of which is equipped with a propensity function (or intensity function in the mathematics literature), a_k(X). The dynamic state of this chemical system can be described by the state vector X(t) =X_1(t)ldotsX_N(t)^T, where X_n(t)n = 1ldotsN, is the number of X_n molecules at time t, and ^T denotes the transpose of the vector in the bracket.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"The delays, tau_k  0 for k = 1ldotsd, are between the initiation and completion of some, or all, of the reactions. And tau_k is used to represent the delay time of the kth reaction in all delayed reactions. Notice that the definition of tau_k is not the next reaction time Delta. We partition the reactions into three sets, those with no delays, denoted textND, those that change the state of the system only upon completion, denoted textCD, and those that change the state of the system at both initiation and completion, denoted textICD. The following assumption, sometimes called the fundamental premise of chemical kinetics, is based upon physical principles and serves as the fundamental assumption for simulation methods of chemically reacting systems with delays:","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"beginaligned\na_k(X(t)) Delta t + omicron (t) =  text the probability that  reaction k \n text takes place in a small time interval t t + Delta t)\nendaligned","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"where omicron (Delta t)Delta t rightarrow 0 as Delta t rightarrow 0.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"Because the assumption above only pertains to the initiation times of reactions, we must handle the completions separately. There are three different types of reactions, so there are three cases that need consideration.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"Case 1: If reaction k is in textND and initiates at time t, then the system is updated by losing the reactant species and gaining the product species at the time of initiation.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"Case 2: If reaction k is in textCD and initiates at time t, then the system is updated only at the time of completion, t + tau_k, by losing the reactant species and gaining the product species.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"Case 3: If reaction k is in textICD and initiates at time t, then the system is updated by losing the reactant species at the time of initiation, t, and is updated by gaining the product species at the time of completion, t + tau_k.","category":"page"},{"location":"algorithms/notations/#References","page":"Notations and Basic Concepts","title":"References","text":"","category":"section"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"[1] Dmitri A. Bratsun, Dmitri N. Volfson, Jeff Hasty, and Lev S. Tsimring \"Non-Markovian processes in gene regulation (Keynote Address)\", Proc. SPIE 5845, Noise in Complex Systems and Stochastic Dynamics III, (23 May 2005). https://doi.org/10.1117/12.609707","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"[2] Manuel Barrio, Kevin Burrage, André Leier, Tianhai Tian. \"Oscillatory Regulation of Hes1: Discrete Stochastic Delay Modelling and Simulation\", PLoS Computational Biology, 10.1371(2006). https://doi.org/10.1371/journal.pcbi.0020117","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"[3] Xiaodong Cai, \"Exact stochastic simulation of coupled chemical reactions with delays\", The Journal of Chemical Physics 126, 124108(2007). https://doi/10.1063/1.2710253","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"[4] David F. Anderson, \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\", The Journal of Chemical Physics 128, 109903(2008). https://doi/10.1063/1.2799998","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"[5] Slepoy, Alexander, Aidan P. Thompson, and Steven J. Plimpton. \"A constant-time kinetic Monte Carlo algorithm for simulation of large biochemical reaction networks.\" The journal of chemical physics 128, no. 20 (2008): 05B618. https://doi.org/10.1063/1.2919546","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"[6] Mauch, Sean, and Mark Stalzer. \"Efficient formulations for exact stochastic simulation of chemical systems.\" IEEE/ACM Transactions on Computational Biology and Bioinformatics 8, no. 1 (2009): 27-35. https://doi.org/10.1109/TCBB.2009.47","category":"page"},{"location":"tutorials/heterogeneous_delay/#A-birth-death-model-with-heterogeneous-fixed-delays","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"","category":"section"},{"location":"tutorials/heterogeneous_delay/#Model-definition","page":"A birth-death model with heterogeneous fixed delays","title":"Model definition","text":"","category":"section"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"We study the following model with delayed production","category":"page"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"emptyset xrightarrowA_n X text triggers  X Rightarrow Y text after tau time\nY xrightarrowB_n emptyset","category":"page"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"This model is studied in [1]. This delayed birth–death process can be used to model the dynamics of chemical species, such as proteins, that are produced through a sequence of reactions. We first consider fixed birth delays, tau_n, which are constant for a given cell but which vary across a population. It is assumed that across the population, production rates, A_n, degradation rates, B_n, and the fixed birth delays, tau_n, follow a gamma distribution. A decrease in protein count is due to growth-induced dilution or enzymatic degradation, and is described by an instantaneous death process with rate B_n.","category":"page"},{"location":"tutorials/heterogeneous_delay/#Markovian-part","page":"A birth-death model with heterogeneous fixed delays","title":"Markovian part","text":"","category":"section"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"To define the Markovian part of the model, we set the model by","category":"page"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"using Catalyst\nusing Distributions, Random\nusing DelaySSAToolkit\nrn = @reaction_network begin\n    A, 0 --> X\n    B, Y --> 0\nend\nu0 = [0, 0] # X, Y\ntf = 100.0\ntspan = (0, tf)\nps = [10.0, 1.0] # A, B. The initial conditions are dummy variables, later on will be drawn from Gamma distributions ","category":"page"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"where X is an extra species that represents the premature product in the delay channel that will turn into Y after a delay time tau_n for each cell n.","category":"page"},{"location":"tutorials/heterogeneous_delay/#Non-Markovian-part","page":"A birth-death model with heterogeneous fixed delays","title":"Non-Markovian part","text":"","category":"section"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"τ = 1 # dummy variable, later on will be drawn from a Gamma distribution \ndelay_trigger = Dict(1 => [1 => τ])\ndelay_complete = Dict(1 => [1 => -1, 2 => 1])\ndelay_interrupt = Dict()\njumpsys = convert(JumpSystem, rn; combinatoric_ratelaws=false)\ndprob = DiscreteProblem(jumpsys, u0, tspan, ps)\nde_chan0 = [[]]\ndelayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)\njprob = DelayJumpProblem(\n    jumpsys, dprob, DelayRejection(), delayjumpset, de_chan0; save_positions=(false, false)\n)","category":"page"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"Here the value of delay_trigger is [1=>τ]. This is of Pair type where the first index refers to the number of the delay channel, and the second index refers to the delay time. Such a definition is equivalent to appending a delay time tau to the first delay channel provided that the first reaction A_n 0rightarrow X happened. de_chan0 is the initial condition for delay channels, here we assume no ongoing delay reactions.","category":"page"},{"location":"tutorials/heterogeneous_delay/#Heterogeneous-fixed-delays","page":"A birth-death model with heterogeneous fixed delays","title":"Heterogeneous fixed delays","text":"","category":"section"},{"location":"tutorials/heterogeneous_delay/#Define-EnsembleProblem","page":"A birth-death model with heterogeneous fixed delays","title":"Define EnsembleProblem","text":"","category":"section"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"# the Gamma distribution in Julia uses shape α, scale θ, Gamma(α,θ). In the paper [1], Gamma distribution uses shape α and rate β. Thus, one needs to set the inverse.\nfunction prob_func(prob, i, repeat)\n    rng = Random.seed!(i) # i is the index for each simulation\n    A = rand(rng, Gamma(8, 1 / 0.23))\n    B = rand(rng, Gamma(9, 1 / 625))\n    τ = rand(rng, Gamma(7, 1))\n    return remake(prob; p=[A, B], delay_trigger=Dict(1 => [1 => τ])) # update the new parameters\nend\nensprob1 = EnsembleProblem(jprob; prob_func=prob_func)\n@time ens1 = solve(ensprob1, SSAStepper(), EnsembleThreads(); trajectories=40, saveat=1.0)","category":"page"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"For each simulation i (modelling an individual cell), a set of parameters A B τ is drawn from Gamma distributions, where we use the parameters defined as in [1]. One only needs to reconstruct the DelayJumpProblem by assigning new values to the parameter p=[A,B] and delay_trigger =  Dict(1=>[1=>τ]) for each simulation. This can be easily done by invoking the remake function.","category":"page"},{"location":"tutorials/heterogeneous_delay/#Visualisation","page":"A birth-death model with heterogeneous fixed delays","title":"Visualisation","text":"","category":"section"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"We can plot the time evolution of 40 simulations. (Image: heterogeneous1)","category":"page"},{"location":"tutorials/heterogeneous_delay/#Distributed-delays","page":"A birth-death model with heterogeneous fixed delays","title":"Distributed delays","text":"","category":"section"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"In [1, Section 3.2], the authors studied the case with distributed delays, where the delay can vary between reactions within and between cells. One can adopt the problem setting by changing few lines of code.","category":"page"},{"location":"tutorials/heterogeneous_delay/#Define-EnsembleProblem-2","page":"A birth-death model with heterogeneous fixed delays","title":"Define EnsembleProblem","text":"","category":"section"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"function prob_func(prob, i, repeat)\n    rng = Random.seed!(i)\n    α = rand(rng, Gamma(63, 1 / 9))\n    β = rand(rng, Gamma(10.0, 1 / 10.0))\n    A = rand(rng, Gamma(8, 1 / 0.23))\n    B = rand(rng, Gamma(9, 1 / 625))\n    τ = rand(rng, Gamma(α, 1 / β))\n    return remake(prob; p=[A, B], delay_trigger=Dict(1 => [1 => τ]))\nend\nensprob2 = EnsembleProblem(jprob; prob_func=prob_func)","category":"page"},{"location":"tutorials/heterogeneous_delay/#Visualisation-2","page":"A birth-death model with heterogeneous fixed delays","title":"Visualisation","text":"","category":"section"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"Note that a simulation of 10^4 samples with very high production number (up to ~1000 for X and ~3000 for Y) only takes few minutes on a laptop:","category":"page"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"julia> @time ens2 = solve(ensprob2, SSAStepper(), EnsembleThreads(); trajectories=10^4)\n","category":"page"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"Here we plot the histogram of the number of unfinished reactant Xs in the delay channel.","category":"page"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"(Image: heterogeneous2)","category":"page"},{"location":"tutorials/heterogeneous_delay/#References","page":"A birth-death model with heterogeneous fixed delays","title":"References","text":"","category":"section"},{"location":"tutorials/heterogeneous_delay/","page":"A birth-death model with heterogeneous fixed delays","title":"A birth-death model with heterogeneous fixed delays","text":"[1] Mark Jayson Cortez, Hyukpyo Hong, Boseung Choi, Jae Kyoung Kim, Krešimir Josić, \"Hierarchical Bayesian models of transcriptional and translational regulation processes with delays\", Bioinformatics, 2021;, btab618, https://doi.org/10.1093/bioinformatics/btab618","category":"page"},{"location":"tutorials/delay_oscillator/#An-auto-regulatory-model-of-oscillatory-gene-expression","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"","category":"section"},{"location":"tutorials/delay_oscillator/#Model","page":"An auto-regulatory model of oscillatory gene expression","title":"Model","text":"","category":"section"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"Let us study the following auto-regulatory network with delay. The model is defined as follows:","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"emptyset xrightarrowJ_1(Y) X\n YxrightarrowJ_2(Y) emptyset","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"Note that emptyset xrightarrowJ_1(Y) X will trigger XRightarrow Y after a delay time tau. ","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"According to [1], it's a simplified auto-regulatory network whereby a protein X is transcribed by a gene, then it is transformed after a delay time tau into a mature protein Y, which binds the promoter and represses the transcription of X. The function J_1(Y) and J_2(Y) is defined as follows:","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"J_1(Y)=k_1SfracK^p_dK^p_d+Y^pJ_2(Y)=k_2E_TfracYK_m+Y","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"In this example, we assume k_1=k_2=S=E_T=K_d=K_m=1 p =2 for simplicity.","category":"page"},{"location":"tutorials/delay_oscillator/#Markovian-part","page":"An auto-regulatory model of oscillatory gene expression","title":"Markovian part","text":"","category":"section"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"We can define the Markovian part of the system using Catalyst","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"rn = @reaction_network begin\n    1/(1+Y^2), 0 --> X\n    1/(1+Y),   Y --> 0\nend","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"Then we convert the reaction network to a JumpSystem","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"jumpsys = convert(JumpSystem, rn, combinatoric_ratelaws=false).","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"We initialize the problem by setting","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"u0 = [0,0]\ntf = 400.0\ntspan = (0,tf)\nτ = 20.0\ndprob = DiscreteProblem(jumpsys, u0, tspan)","category":"page"},{"location":"tutorials/delay_oscillator/#Non-Markovian-part","page":"An auto-regulatory model of oscillatory gene expression","title":"Non-Markovian part","text":"","category":"section"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"We define the DelayJumpSet by","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"delay_trigger_affect! = function (integrator, rng)\n    append!(integrator.de_chan[1], τ)\nend\ndelay_trigger = Dict(1=>delay_trigger_affect!)\ndelay_complete = Dict(1=>[2=>1, 1=>-1])\ndelay_interrupt = Dict()\ndelayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"To see how to define the DelayJumpSet, we refers to this example. Thus, we can define the DelayJumpProblem by ","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"de_chan0 = [[]]\ndjprob = DelayJumpProblem(jumpsys, dprob, DelayRejection(), delayjumpset, de_chan0, save_positions=(true,true)).","category":"page"},{"location":"tutorials/delay_oscillator/#Solution-and-Visualization","page":"An auto-regulatory model of oscillatory gene expression","title":"Solution and Visualization","text":"","category":"section"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"Now we can solve the problem and plot two trajectories of X and Y.","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"sol_1 = solve(djprob, SSAStepper(), seed = 1)\nsol_2 = solve(djprob, SSAStepper(), seed = 2)","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"(Image: oscillator1) (Image: oscillator2)","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"Then we simulate 10^4 trajectories and calculate the evolution of mean value for each reactant.","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"using StatsBase\nens_prob = EnsembleProblem(djprob)\nens = solve(ens_prob,SSAStepper(), EnsembleThreads(), trajectories = 1e4, saveat = .1)","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"(Image: oscillator3)","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"If we plot how the mean of Y varies with respect to the mean of X, we will find the following oscillatory orbit in the phase diagram.","category":"page"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"(Image: oscillator4)","category":"page"},{"location":"tutorials/delay_oscillator/#References","page":"An auto-regulatory model of oscillatory gene expression","title":"References","text":"","category":"section"},{"location":"tutorials/delay_oscillator/","page":"An auto-regulatory model of oscillatory gene expression","title":"An auto-regulatory model of oscillatory gene expression","text":"[1] Qingchao Jiang, Xiaoming Fu, Shifu Yan, Runlai Li, Wenli Du, Zhixing Cao, Feng Qian, Ramon Grima, \"Neural network aided approximation and parameter inference of non-Markovian models of gene expression\". Nature communications, (2021) 12(1), 1-12. https://doi.org/10.1038/s41467-021-22919-1","category":"page"},{"location":"api/#Main-API","page":"API","title":"Main API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = DelaySSAToolkit","category":"page"},{"location":"api/","page":"API","title":"API","text":"DelayJumpSet\nDelayJumpProblem","category":"page"},{"location":"api/#DelaySSAToolkit.DelayJumpSet","page":"API","title":"DelaySSAToolkit.DelayJumpSet","text":"mutable struct DelayJumpSet{T1, T2, T3<:Function}\n\nA delay jump set that consists of five inputs, namely delay_trigger, delay_interrupt, delay_complete, delay_trigger_set and delay_interrupt_set. One only need to specify the first three inputs and the rest two can be automatically generated.\n\nFields\n\ndelay_trigger: reactions in the Markovian part that trigger the change of the state of the delay channels or/and the state of the reactants upon initiation.\ndelay_complete: reactions in the Markovian part that change the state of the delay channels or/and the state of the reactants in the middle of on-going delay reactions.\ndelay_interrupt: reactions that are initiated by delay trigger reactions and change the state of the delay channels or/and the state of the reactants upon completion.\ndelay_trigger_set: collection of indices of reactions that can interrupt the delay reactions. of delay_trigger.\ndelay_interrupt_set: collection of indices of delay_interrupt.\n\nNotes\n\ndelay_trigger::Dict{Int,T}: reactions in the Markovian part that trigger the change of the state of the delay channels or/and the state of the reactants upon initiation.\nKeys: Indices of reactions defined in the Markovian part that can trigger the delay reactions; \nValues: value type T can be either \nFunction:  a function that decides how to update the delay channel and/or the state of the reactants. For example, one can define\ndelay_trigger_affect! = function(integrator, rng)\n    append!(integrator.de_chan[1], rand(rng))\n    integrator.u[2] +=1\nend\nwhich means adding a random number (with a given random seed rng) in (0,1) to the first delay channel, and adding 1 individual to the second species.\nVector{Pair{Int,T2}} where T2<:Union{Real, Vector{Real}}  a pair type is a simplified update function for only changing the delay channel (which will render better performance). For example, setting delay_trigger_affect! = [1=>τ] is equivalent to \ndelay_trigger_affect! = function(integrator, rng)\n    append!(integrator.de_chan[1], τ)\nend\ndelay_interrupt::Dict{Int,Function}: reactions in the Markovian part that change the state of the delay channels or/and the state of the reactants in the middle of on-going delay reactions. \nKeys: Indices of reactions defined in the Markovian part that can interrupt the delay reactions; \nValues: value type T can be an update function of Function type that decides how to update the delay channel or the state of the reactants.\ndelay_complete::Dict{Int,T}: reactions that are initiated by delay trigger reactions and change the state of the delay channels or/and the state of the reactants upon completion. \nKeys: Indices of the delay channel; \nValues: value type T can be either an update function of Function type or a Vector{Pair{Int,Int}} type that decides how to update the delay channel or the state of the reactants upon completion\ndelay_trigger_set::Vector{Int}: collection of indices of reactions that can trigger the delay reaction.\ndelay_interrupt_set::Vector{Int}: collection of  indices of reactions that can interrupt the delay reactions.\n\nWe take this model for example.\n\n# Take the following example \n# C: 0 --> X_A\n# γ: X_A --> 0\n# β: X_A -->  X_I, which triggers  X_I ==> 0 after time τ\n# γ: X_I -->0 \n\n# the 3rd reaction will trigger a delay reaction\ndelay_trigger_affect! = function (integrator, rng)\n  append!(integrator.de_chan[1], τ)\nend\n# this is equivalent to \n# delay_trigger = Dict(3=>[1=>τ])\ndelay_trigger = Dict(3=>delay_trigger_affect!)\n\n# the 1st delay reaction will cause the 2nd species of molecule to degrade\ndelay_complete = Dict(1=>[2=>-1])\n\n\n# the 4th reaction will interrupt the delay reactions\ndelay_interrupt_affect! = function (integrator, rng)\n   i = rand(rng, 1:length(integrator.de_chan[1]))\n   deleteat!(integrator.de_chan[1],i)\nend\ndelay_interrupt = Dict(4=>delay_interrupt_affect!) \n\n\ndelaysets = DelayJumpSet(delay_trigger,delay_complete,delay_interrupt)\n\n\n\n\n\n","category":"type"},{"location":"api/#DelaySSAToolkit.DelayJumpProblem","page":"API","title":"DelaySSAToolkit.DelayJumpProblem","text":"function DelayJumpProblem(prob::DiscreteProblem, aggregator::AbstractDelayAggregatorAlgorithm, jumps::JumpSet, delayjumpset::DelayJumpSet, de_chan0)\n\nFields\n\nprob::DiscreteProblem\nA discrete problem defined by the initial values.\naggregator::AbstractDelayAggregatorAlgorithm\nA given algorithm to solve the DelaySSA problem.\njumps::JumpSet\nA jumpset containing the information of Markovian part.\ndelayjumpset::DelayJumpSet\nA delay jumpset containing the information of Non-Markovian part.\nde_chan0::Vector{Vector{T}} \nThe initial condition of the delay channel.\n\n\n\n\n\nfunction DelayJumpProblem(js::JumpSystem, prob, aggregator, delayjumpset, de_chan0; kwargs...)\n\nFields\n\njs::JumpSystem  \nA jump system containing the information of Markovian part, defined by Catalyst.\nprob::DiscreteProblem\nA discrete problem defined by the initial values.\naggregator::AbstractDelayAggregatorAlgorithm\nA given algorithm to solve the DelaySSA problem.\ndelayjumpset::DelayJumpSet\nA delay jumpset containing the information of Non-Markovian part.\nde_chan0::Vector{Vector{T}} \nThe initial condition of the delay channel.\n\n\n\n\n\n","category":"type"},{"location":"api/#Types-and-Algorithms","page":"API","title":"Types and Algorithms","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractDelayAggregatorAlgorithm\nDelayDirect\nDelayRejection\nDelayMNRM\nDelayDirectCR","category":"page"},{"location":"api/#DelaySSAToolkit.AbstractDelayAggregatorAlgorithm","page":"API","title":"DelaySSAToolkit.AbstractDelayAggregatorAlgorithm","text":"abstract type AbstractDelayAggregatorAlgorithm\n\nAn abstract type that contains delay stochastic simulation algorithms:\n\nDelayDirect\nDelayRejection\nDelayMNRM\nDelayDirectCR\nDelayCoevolve\n\n\n\n\n\n","category":"type"},{"location":"api/#DelaySSAToolkit.DelayDirect","page":"API","title":"DelaySSAToolkit.DelayDirect","text":"struct DelayDirect <: DelaySSAToolkit.AbstractDelayAggregatorAlgorithm\n\nDelay Direct Method from  Xiaodong Cai, \"Exact stochastic simulation of coupled chemical reactions with delays\", The Journal of Chemical Physics 126, 124108(2007).\n\n\n\n\n\n","category":"type"},{"location":"api/#DelaySSAToolkit.DelayRejection","page":"API","title":"DelaySSAToolkit.DelayRejection","text":"struct DelayRejection <: DelaySSAToolkit.AbstractDelayAggregatorAlgorithm\n\nDelay Rejection Method from Barrio, Manuel, Kevin Burrage, André Leier, and Tianhai Tian. \"Oscillatory regulation of Hes1: discrete stochastic delay modelling and simulation.\" PLoS computational biology 2, no. 9 (2006): e117..\n\n\n\n\n\n","category":"type"},{"location":"api/#DelaySSAToolkit.DelayMNRM","page":"API","title":"DelaySSAToolkit.DelayMNRM","text":"struct DelayMNRM <: DelaySSAToolkit.AbstractDelayAggregatorAlgorithm\n\nA modifed version of the Delay Next Reaction Method from David F. Anderson, \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\", The Journal of Chemical Physics 128, 109903(2008).\n\n\n\n\n\n","category":"type"},{"location":"api/#DelaySSAToolkit.DelayDirectCR","page":"API","title":"DelaySSAToolkit.DelayDirectCR","text":"struct DelayDirectCR <: DelaySSAToolkit.AbstractDelayAggregatorAlgorithm\n\nA modifed Composition-Rejection Direct Method with delays (DelayDirectCR), implementation combining features from the original article and from the code in  JumpProcesses package: DirectCR : A constant-time kinetic Monte Carlo algorithm for simulation of large biochemical reaction networks, by A. Slepoy, A.P. Thompson and S.J. Plimpton, J. Chem. Phys, 128, 205101 (2008). and Efficient Formulations for Exact Stochastic Simulation of Chemical Systems, by S. Mauch and M. Stalzer, ACM Trans. Comp. Biol. and Bioinf., 8, No. 1, 27-35 (2010).\n\n\n\n\n\n","category":"type"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/#Exact-stochastic-simulation-algorithm-(SSA)-without-delays","page":"Theory","title":"Exact stochastic simulation algorithm (SSA) without delays","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Consider a system consisting of N geq 1 chemical species, X_1ldots X_N, undergoing M geq 1 chemical reactions through reaction channels R_1ldotsR_M, each of which is equipped with a propensity function (or intensity function in the mathematics literature), a_k(X). The dynamic state of this chemical system can be described by the state vector X(t) =X_1(t)ldotsX_N(t)^T, where X_n(t)n = 1ldotsN is the number of X_n molecules at time t, and ^T denotes the transpose of the vector in the bracket.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Following Gillespie [1], the dynamics of reaction R_k are defined by a state-change vector nu_k = nu_1k ldotsnu_Nk^T, where nu_nk gives the changes in the X_n molecular population produced by one R_k reaction, and a propensity function a_k(t), which can also be dependent on the state, i.e. a_k(t)=hata_k(tX(t)) (here for simplicity denoted as a_k(t)), together with the fundamental premise of stochastic chemical kinetics:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\na_k(t)Delta t = text the probability given  X(t)=mathbfx \ntext that one reaction R_k text will occur in the\ntext next infinitesimal time interval tt+Delta t\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Defining the probability rate constant c_k as the probability that a randomly selected combination of R_k reactant molecules reacts in a unit time period, we can calculate a_k(t) from c_k and the molecular numbers of R_k reactants at time t using the method given by Gillespie.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For a chemical system in a given state X(t)=mathbfx at time t, assuming that all reactions occur instantly, Gillespie’s exact SSA answers the following two questions: (i) when will the next reaction occur?  (ii) which reaction will occur? Specifically, Gillespie’s exact SSA simulates the following event in each step:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\ntextE   textno reaction occurs in the time interval tt+Delta\n textand a reaction R_mu  textoccurs in the infinitesimal\n texttime interval t+Deltat+Delta+Delta t\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Based upon the fundamental premise Eq. (1), Gillespie devised an exact stochastic simulation algorithm (SSA) that involves drawing two random numbers Delta and mu which are independent and distributed according to probability density functions (PDFs) (3) and (4), respectively. Delta tells us how long we have to wait until the next reaction and mu tells us which is the next reaction:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nf_Delta(Delta)=a_0(t) exp(-a_0(t)Delta)     Delta  0\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nf_mu(mu)=a_mu(t) over a_0(t)      mu = 1ldotsM\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where a_0(t)=beginmatrix sum_k=1^M a_k(t) endmatrix. According to the PDF Eq. (4), a realization of mu can be generated from a standard uniform random variable r_2, by taking mu to be the integer for which sum_k=1^mu-1 a_k(t)   r_2 a_0(t) leq sum_k=1^mu a_k(t);based on the PDF Eq. (3), a realization of Delta can be generated from another standard uniform random variable r_1 as Delta=ln(r_1)a_0(t). Therefore, Gillespie’s exact SSA generates a realization of mu and Delta in each step of simulation, and then updates the time and system state as tleftarrow t+Delta and mathbfx leftarrow mathbfx+ mathbfnu_mu, respectively.","category":"page"},{"location":"theory/#Exact-SSA-for-stochastic-modelling-coupled-with-delays","page":"Theory","title":"Exact SSA for stochastic modelling coupled with delays","text":"","category":"section"},{"location":"theory/#Delay-direct-method","page":"Theory","title":"Delay direct method","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"As in the derivation of Gillespie’s exact SSA, we first need to find the probability of event Eq. (2), that is defined as P(Deltamu)textdDelta, where P(Deltamu) is the joint PDF of Delta and mu. Suppose that there are d ongoing reactions at time t, which will finish at t+T_1ldotst+T_d, respectively. Without loss of generality, we assume that T_1 leq T_2 leq ldots leq T_d. Unlike in the reaction system without delays where the propensity functions remain unchanged in the time interval tt+Delta, the propensity functions here change at t+T_ii=1ldotsd, due to delayed reactions. We need to take into account such changes in propensity functions when deriving P(Deltamu).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"As in the derivation of Gillespie’s exact SSA, P(Deltamu)textdDelta can be found from the fundamental premise Eq. (1) as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nP(Deltamu)textdDelta=P_0(Delta) a_mu(t +Delta)textdDelta\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where P_0(Delta) is the probability that no reaction will occur in the time interval tt+Delta, while a_mu(t+Delta)textdDelta is the probability that a reaction R_mu occurs in t+Deltat+Delta+textdDelta. Defining T_0=0 and T_d+1=infty, we can find P_0(Delta) for Delta that lies in different time intervals T_iT_i+1)i=0ldotsd. If Delta in T_iT_i+1), we define the event E_k as the event that no reaction occurs in the time interval t+T_kt+T_k+1)k=0ldotsk=i1, respectively, and the event  E_i  as the event that no reaction occurs in the time interval t+T_it+Delta). Then, we can express P_0(Delta) as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nP_0(Delta)=P(E_0ldotsE_i)=P(E_0) prod_k=1^i P(E_k丨E_0ldotsE_k-1)\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"From the derivation of Gillespie’s exact SSA, we know that","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"P(E_0) = exp (a_0(t)T_1)\nP_0(E_k丨E_0ldotsE_k-1) = exp(-a_0(t+T_k))  (T_k+1T_k)k=0ldotsi1\nP(E_i丨E_0ldotsE_i-1) = exp(-a_0(t+T_i)(Delta-T_i))","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that propensity functions change at t+T_k after a delayed reaction finishes, and we use a_0(t+T_k) to represent the new a_0. The probability P_0(Delta) is then given by","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\n P_0(Delta) = exp bigg (-sum_k=0^i-1 a_0(t+T_k)(T_k+1-T_k)-a_0(t+T_i)(Delta-T_i) bigg ) \n Delta in T_iT_i+1) i = 0ldotsd\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we assume that the first term of the exponent is equal to zero when i = 0. Since P_0(Delta) does not depend on individual propensity functions, as shown in Eq. (7), it is seen from Eq. (5) that Delta and mu are independent random variables. Combining Eq. (5) and Eq. (7) and noticing that a_mu(t+Delta)=a_mu(t+T_i) for Delta in T_iT_i+1), we obtain the PDF of Delta and mu as follows:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\n f_Delta(Delta) = a_0(t+T_i) exp bigg (-sum_k=0^i-1 a_0(t+T_k)(T_k+1-T_k) - a_0(t+T_i)(Delta-T_i) bigg ) \n Delta in T_iT_i+1) i = 0ldotsd\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"f_mu(mu)= a_mu(t+T_i) over a_0(t+T_i)     mu = 1ldotsM    Delta in T_iT_i+1)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"It is not difficult to verify that int_0^infty f_Delta(Delta) textdDelta = 1. In simulation, mu can be generated, from a standard uniform random variable u_1, by taking mu to be the integer for which","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"sum_k=1^mu-1 a_k(t+T_i)   u_1 a_0(t+T_i)   sum_k=1^mu a_k(t+T_i)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"after Delta is generated to be in the time interval T_iT_i+1). We next derive the method of generating  Delta according to its PDF in Eq. (8).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The cumulative distribution function of Delta can be found from Eq. (8) as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n F_Delta(Delta)=1 - exp  bigg (-sum_k=0^i-1 a_0(t+T_k)(T_k+1-T_k)-a_0(t+T_i)(Delta-T_i) bigg ) \n Delta in T_iT_i+1) i = 0ldotsd\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, we can generate Delta from a standard uniform random variable u_2, by taking Delta=F_Delta^1(u_2), where F_Delta^1(cdot) represents the inverse of F_Delta(Delta). More specifically, we can obtain Delta as follows:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Find T_i such that  F_Delta(T_i)  u_2  F_Delta(T_i+1), then calculate  Delta from","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n Delta = T_i + -ln (1-u_2)-beginmatrix sum_k=0^i-1 a_0(t+T_k)(T_k+1-T_k) endmatrix  over a_0(t+T_i) \n Delta in T_iT_i+1)\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since we need T_1ldotsT_d to generate Delta and mu, we define an array of data structures, named Tstruct, whose ith (i=1ldotsd) cell stores T_i and the index, mu_i, of the reaction that T_i is associated with. The reaction index mu_i is needed during the generation of Delta, when we update the propensity functions affected by the reaction that is delayed but finishes at t+T_i. During simulation, we need to generate Delta and mu, maintain Tstruct, and then update the state vector X(t). We refer to delay direct algorithm for details.","category":"page"},{"location":"theory/#delay_rejection_method","page":"Theory","title":"Delay rejection method","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Bratsun et al. [3] and Barrio et al. [4] used an algorithm for computing the initiation times that is exactly like the original Gillespie Algorithm except that if there is a stored delayed reaction set to finish within a computed time step, then the computed time step is discarded, and the system is updated to incorporate the stored delayed reaction. The algorithm then attempts another step starting at its new state. This algorithm is called the Rejection Method. We briefly summarized this algorithm in delay rejection method.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The rejection algorithm essentially generates Delta in the event (2) using a rejection method in an iterative fashion: in the i-th iteration, it generates a Delta_i according to an exponential PDF with parameter a_0(t+T_i1), where we have denoted the time to next event generated in the i-th iteration as Delta_i. If Delta_i  T_i - T_i1, then we have Delta = T_i-1 + Delta_i and the algorithm continues simulation to generate mu; otherwise, it rejects Delta_i, updates the state vector X(t+T_i), calculates a_k(t+T_i)k=1ldotsM, and goes to the next iteration. If Delta is determined in the (i+1)-th iteration, where i is a non-negative integer, then we have Delta in T_iT_i+1) and i delayed reactions finished in the time interval tt+Delta).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We point out the following equivalence:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"note: Note\nFor a given integer i, the event Delta in T_iT_i+1) in the delay direct method is equivalent to the event Delta_1Delta_2ldotsDelta_i are rejected and the time to the next event Delta_i+1 is accepted, i.e. Delta_i+1+T_i=Delta in the delay rejection method.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"From the iterative procedure of generating Delta described above, we can find P_0(Delta) that the rejection method algorithm produces. Specifically, if Delta in T_iT_i+1), we have","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"P(E_0)=P(Delta_1  T_1)\nP(E_k丨E_0ldotsE_k-1) = P(Delta_k+1  T_k+1 - T_k) k=1ldotsi1","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"because Delta_kk=1ldotsi, are rejected. Since Delta_i+1 is accepted, at least one reaction will occur in the time interval t+T_it+Delta), if Delta_i+1  Delta T_i. Thus, P(E_i丨E_0ldotsE_i-1) = 1P(Delta_i+1  Delta - T_i) = P(Delta_i+1  Delta - T_i). Therefore, for the rejection method, P_0(Delta) in Eq. (6) can be written as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nP_0(Delta) = P(Delta_i+1  Delta - T_i) prod_k=1^i P(Delta_k  T_k - T_k-1)\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The random variables Delta_kk=1ldotsi+1, follow an exponential distribution with parameter a_0(t+T_k1), and thus we have","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\n P(Delta_k  T_k - T_k-1) = exp(-a_0(t+T_k-1)(T_k - T_k-1)) \n k= 1ldotsi\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nP(Delta_i+1  Delta T_i) = exp(-a_0(t+T_i)(Delta-T_i))\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Substituting Eqs. (10) and (11) into Eq. (9), we find that P_0(Delta) in Eq. (9) is exactly the same as P_0(Delta) in Eq. (7) that is derived directly from the event (2) and the fundamental premise (1). Since the delay direct algorithm generates Delta and mu according to PDFs of Delta and mu derived from P_0(Delta) in Eq. (7), the rejection method is equivalent to the direct method and also is an exact SSA for chemical reaction systems with delays.","category":"page"},{"location":"theory/#Other-Methods","page":"Theory","title":"Other Methods","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"The rigorous proof of delay rejection method opens a way to transform any exact SSA method to an exact delay SSA method. If we denote dt_reaction as the time to the next reaction generated by the instantaneous reactions R_1ldotsR_M using a given exact stochastic simulation algorithm method, for instance next reaction method [5], direct method with composition and rejection [6-7], partial propensity method [8] etc. To extend such an SSA method to a delay SSA method, it suffices to compare dt_reaction with dt_delay which is the time to the next delay reaction (the minimum delay time in the delay channels). If dt_reaction < dt_delay, we reject dt_delay, otherwise accept dt_delay. Based on the proof in delay rejection method, such an extension guarantees to the exactness of transformed delay SSA method.","category":"page"},{"location":"theory/#References","page":"Theory","title":"References","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"[1] Daniel T. Gillespie, \"Exact stochastic simulation of coupled chemical reactions\", The Journal of Physical Chemistry 1977 81 (25), 2340-2361. https://doi.org/10.1021/j100540a008","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[2] Xiaodong Cai, \"Exact stochastic simulation of coupled chemical reactions with delays\", The Journal of Chemical Physics 126, 124108(2007). https://doi/10.1063/1.2710253","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[3] Dmitri A. Bratsun, Dmitri N. Volfson, Jeff Hasty, and Lev S. Tsimring \"Non-Markovian processes in gene regulation (Keynote Address)\", Proc. SPIE 5845, Noise in Complex Systems and Stochastic Dynamics III, (23 May 2005). https://doi.org/10.1117/12.609707","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[4]  Manuel Barrio, Kevin Burrage, André Leier, Tianhai Tian. \"Oscillatory Regulation of Hes1: Discrete Stochastic Delay Modelling and Simulation\", PLoS Computational Biology, 10.1371(2006). https://doi.org/10.1371/journal.pcbi.0020117","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[5] David F. Anderson, \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\", The Journal of Chemical Physics 128, 109903(2008). https://doi/10.1063/1.2799998","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[6] Slepoy, Alexander, Aidan P. Thompson, and Steven J. Plimpton. \"A constant-time kinetic Monte Carlo algorithm for simulation of large biochemical reaction networks.\" The journal of chemical physics 128, no. 20 (2008): 05B618. https://doi.org/10.1063/1.2919546","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[7] Mauch, Sean, and Mark Stalzer. \"Efficient formulations for exact stochastic simulation of chemical systems.\" IEEE/ACM Transactions on Computational Biology and Bioinformatics 8, no. 1 (2009): 27-35. https://doi.org/10.1109/TCBB.2009.47","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[8] Ramaswamy, Rajesh, and Ivo F. Sbalzarini. \"A partial-propensity formulation of the stochastic simulation algorithm for chemical reaction networks with delays.\" The Journal of chemical physics 134, no. 1 (2011): 014106. https://doi.org/10.1063/1.3521496","category":"page"},{"location":"tutorials/tutorials/#seir_model","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"This tutorial aims to explain how to use DelaySSAToolkit to define chemical reaction models, solve the problems and visualize the results. The source code of all the examples and figures is available in the GitHub examples folder. To demonstrate these functionalities, we will consider a specific case from epidemic modelling as follows","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"S+IxrightarrowrhoE+I\nIstackrelrrightarrowR","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Notice that S+Ixrightarrowrho E+I will trigger ERightarrow I after tau time, where S, E, I and R are the susceptible, exposed, infected and recovered populations.  This means, with rate rho, a susceptible contacted by an infected will immediately become an individual that is exposed to the disease, and then it takes a certain amount of time delay tau to become an infected individual.","category":"page"},{"location":"tutorials/tutorials/#Model","page":"Tutorials","title":"Model","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"For the non-Markovian model, what differs from the Markovian model is the introduction of delay reactions. To show how we incorporate the delay reactions into the Markovian system, we first need to define the Markovian part and then its non-Markovian part. These two parts mainly form a DelayJumpProblem. Here we show two routes to define our delay system, one way is based on JumpSystem, DiscreteProblem and DelayJumpSet, and the other is based on JumpSet, DiscreteProblem and DelayJumpSet.","category":"page"},{"location":"tutorials/tutorials/#First-route:-JumpSystem-DiscreteProblem-DelayJumpSet","page":"Tutorials","title":"First route: JumpSystem + DiscreteProblem + DelayJumpSet","text":"","category":"section"},{"location":"tutorials/tutorials/#Markovian_part","page":"Tutorials","title":"Markovian part","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Catalyst.jl provides a comprehensive interface to model reaction networks in Julia and can be used to construct models fully-compatible with DelaySSAToolkit. For more details on how to construct a reaction network, we recommend reading Catalyst's tutorial. In our example, the Markovian part (model without delays) of the model can be defined as:","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"rn = @reaction_network begin\n    ρ, S+I --> E+I\n    r, I --> R\nend","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"We can easily obtain a Jumpsystem from the reaction network rn.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"jumpsys = convert(JumpSystem, rn, combinatoric_ratelaws=false)","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"where combinatoric_ratelaws is an optional parameter that specifies whether the rate constants correspond to stochastic rate constants in the sense used by Gillespie [1]. By default, the rates are rescaled. This means that for a reaction such as 2A oversetkrightarrow B, the jump rate function would be kA(A-1)2. To avoid having the reaction rates rescaled (by 12 for this example), one can pass the constructor the optional named parameter combinatoric_ratelaws=false (see reaction rate laws used in simulations for details).","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"With the initial conditions, we can then define DiscreteProblem","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"u0 = [999,1,0,0] # S, I, E, R\ntf = 400.0\ntspan = (0.0,tf)\nps = [1e-4, 1e-2] # parameters for ρ, r\nτ = 20.0\ndprob = DiscreteProblem(jumpsys,u0,tspan,ps)","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"where DiscreteProblem has inputs as the jump system jumpsys, the initial condition of reactants u0, the simulation timespan tspan and the reaction rates ps. ","category":"page"},{"location":"tutorials/tutorials/#Non-Markovian-part","page":"Tutorials","title":"Non-Markovian part","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The non-Markovian part mainly consists of three parts:","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"delay trigger reactions: those reactions in the Markovian part that trigger the change of the delay channels or/and the state of the reactants upon initiation.\ndelay interrupt reactions: those reactions in the Markovian part that change the delay channels or/and the state of the reactants in the middle of ongoing delay reactions.\ndelay complete reactions: those reactions that are initiated by delay trigger reactions and change the delay channels or/and the state of the reactants upon completion.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"With these three definitions in mind and based on this particular example, we define the DelayJumpSet by","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"delay_trigger_affect! = function (integrator, rng)\n    append!(integrator.de_chan[1], τ)\nend\ndelay_trigger = Dict(1=>delay_trigger_affect!)\ndelay_interrupt = Dict()\ndelay_complete = Dict(1=>[2=>1, 3=>-1])\ndelayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"delay_trigger::Dict  A dictionary that contains\nKeys: Indices of reactions defined in the Markovian part that can trigger delay reactions (see Remark on the reaction indices). Here we have the first reaction S+IRightarrow E+ I (represented by delay_trigger = Dict(1=>...)) that will trigger the transfer from E to I after time tau.\nValues: An update function that determines how to update the delay channel. In this example, once the delay reaction is triggered, the first delay channel will be added a delay time tau. The update function has two inputs: 1. integrator: which stores the current state of the reactants (integrator.u) and the delay channels (integrator.de_chan); 2. rng: the random seed for a given stochastic simulation.\ndelay_interrupt::Dict\nThere are no delay interrupt reactions in this example, so we set delay_interrupt = Dict().\ndelay_complete::Dict \nKeys: Indices of delay channels. Here we only have one delay channel.\nValues: A vector of Pairs, mapping species index to net change of stoichiometric coefficient. Here once the delay reaction is completed, the third species E is transferred to the second I, thus the net change of the second species is 1 and the third -1. For the details about the order of the species see Remark.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"We refer to Defining a DelayJumpSet (bursty model) and Defining a DelayJumpSet(birth-death model) for more details.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Now we can define the DelayJumpProblem by ","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"de_chan0 = [[]]\ndjprob = DelayJumpProblem(jumpsys, dprob, DelayRejection(), delayjumpset, de_chan0, save_positions=(true,true))","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"where DelayJumpProblem inputs jumpsys,DiscreteProblem, DelayJumpSet, the algorithm and the initial condition of the delay channel de_chan0.  Here de_chan0 is the initial condition for the delay channel, which is a vector of arrays whose kth entry stores the scheduled delay time for kth delay channel. Here the only delay channel is for exposed population, and we assume E(0) = 0.  The optional keyword argument save_positions is a Boolean tuple for whether to save before and after the event. Then one can use ","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"sol = solve(djprob, SSAStepper())","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"to solve the problem.","category":"page"},{"location":"tutorials/tutorials/#second_route","page":"Tutorials","title":"Second route: JumpSet + DiscreteProblem + DelayJumpSet","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Now we explain how to define the DelayJumpProblem in another way. To that aim, we first define the parameters and the mass-action jump (see Defining a Mass Action Jump for details) and construct a Jumpset.","category":"page"},{"location":"tutorials/tutorials/#Markovian-part","page":"Tutorials","title":"Markovian part","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"ρ, r = [1e-4, 1e-2]\nrates = [ρ, r]\nreactant_stoich = [[1=>1,2=>1],[2=>1]]\nnet_stoich = [[1=>-1,3=>1],[2=>-1,4=>1]]\nmass_jump = MassActionJump(rates, reactant_stoich, net_stoich; scale_rates =false)\njumpset = JumpSet((),(),nothing,mass_jump)","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"We briefly explain the notations here:","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"rates is a vector of rates of reactions.\nreactant_stoich is a vector whose kth entry is the reactant stoichiometry of the kth reaction. The reactant stoichiometry for an individual reaction is assumed to be represented as a vector of Pairs, mapping species index to stoichiometric coefficient.\nnet_stoich is assumed to have the same type as reactant_stoich; a vector whose kth entry is the net stoichiometry of the kth reaction. The net stoichiometry for an individual reaction is again represented as a vector of Pairs, mapping species index to the net change in the species when the reaction occurs.\nscale_rates is an optional parameter that specifies whether the rate constants correspond to stochastic rate constants in the sense used by Gillespie. This has the same functionality as combinatoric_ratelaws in the conversion to a JumpSystem (see Markovian part).","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The JumpSet consists of four inputs, namely variable jumps, constant rate jumps, regular jumps and mass-action jumps. As far as discrete stochastic simulation is concerned, we only focus on constant rate jumps and mass-action jumps which are the second and fourth entries of JumpSet (see different jump types). Here we only have two mass-action jumps that are wrapped in mass_jump. Then we initialize the problem by setting","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"u0 = [999,1,0,0]\nde_chan0 = [[]]\ntf = 400.\ntspan = (0,tf)\nτ = 20.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"As before, we can define the DiscreteProblem","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"dprob = DiscreteProblem(u0, tspan)","category":"page"},{"location":"tutorials/tutorials/#Non-Markovian-part-2","page":"Tutorials","title":"Non-Markovian part","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"In the same way, we can define the  DelayJumpSet by","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"delay_trigger_affect! = function (integrator, rng)\n    append!(integrator.de_chan[1], τ)\nend\ndelay_trigger = Dict(1=>delay_trigger_affect!)\ndelay_complete = Dict(1=>[2=>1, 3=>-1])\ndelay_interrupt = Dict()\ndelayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Now we can define the problem","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"djprob = DelayJumpProblem(dprob, DelayRejection(), jumpset, delayjumpset, de_chan0, save_positions=(true,true)).","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"At last, we can solve the problem and visualize it","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"sol = solve(djprob, SSAStepper())","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"(Image: seir)","category":"page"},{"location":"tutorials/tutorials/#Remark","page":"Tutorials","title":"Remark","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"note: Note\nTo check the order of the species in a reaction network rn::ReactionSystem (or a jumpsys::JumpSystem), one can call species(rn) (or states(jumpsys) respectively). Converting a ReactionSystem defined by Catalyst into a JumpSystem might change the order of the reactions that is in your original reaction network. Internally, all MassActionJumps are ordered before ConstantRateJumps (with the latter internally ordered in the same order they were passed in). The same principle applies for the construction of a JumpSet.  ","category":"page"},{"location":"tutorials/delay_degradation/#A-birth-death-example-with-delay-degradation","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"","category":"section"},{"location":"tutorials/delay_degradation/#Model","page":"A birth-death example with delay degradation","title":"Model","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"The model is defined as follows:","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"beginaligned\nemptyset xrightarrowC X_A \nX_A xrightarrowgamma emptyset\nX_A xrightarrowbeta  X_I text which triggers   X_IRightarrow emptyset text after delay  tau\nX_I xrightarrowgamma emptyset  \nendaligned","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Notice that the last reaction X_I xrightarrowgamma emptyset causes the delay channel to change its state during a scheduled delay reaction.","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"This example is studied by Lafuerza and Toral in [1], where one can solve the solution analytically. If we denote langle X_Arangle(t) to be the mean value of X_A at time t, and langle X_Irangle(t) the mean value of X_I at time t, then","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"langle X_Arangle(t)= fracCa( 1-e^-at )quad langle X_Irangle(t) = begincases\nfracCbetaa-γbigfrac1-e^-γtγ-frac1-e^-atabig t in 0tau\nfracCbetaaBigfrac1-e^-γτγ+frac(1-e^tau(a-γ))a-γe^-atBig  t in (tauinfty)\nendcases","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"where a = β + γ.","category":"page"},{"location":"tutorials/delay_degradation/#Markovian-part","page":"A birth-death example with delay degradation","title":"Markovian part","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"using Catalyst, DelaySSAToolkit\nrn = @reaction_network begin\n    C, 0 --> Xₐ\n    γ, Xₐ --> 0\n    β, Xₐ --> Xᵢ\n    γ, Xᵢ --> 0\nend\njumpsys = convert(JumpSystem, rn; combinatoric_ratelaws=false)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"We refer to this example for more details about the construction of a reaction network. Then we initialize the problem by setting","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"u0 = [0, 0]\ntf = 30.0\nsaveat = 0.1\nC, γ, β = [2.0, 0.1, 0.5]\np = [C, γ, β]\ntspan = (0.0, tf)\ndprob = DiscreteProblem(u0, tspan, p)","category":"page"},{"location":"tutorials/delay_degradation/#Non-Markovian-part","page":"A birth-death example with delay degradation","title":"Non-Markovian part","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Then we turn to the definition of delay reactions","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"τ = 15.0\ndelay_trigger_affect! = function (integrator, rng)\n    return append!(integrator.de_chan[1], τ)\nend\ndelay_trigger = Dict(3 => delay_trigger_affect!)\ndelay_complete = Dict(1 => [2 => -1])\ndelay_affect! = function (integrator, rng)\n    i = rand(rng, 1:length(integrator.de_chan[1]))\n    return deleteat!(integrator.de_chan[1], i)\nend\ndelay_interrupt = Dict(4 => delay_affect!)\ndelaysets = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"delay_trigger\nKeys: Indices of reactions defined in Markovian part that can trigger the delay reaction. Here we have the 3rd reaction beta X_A rightarrow X_I that will trigger the degradation of X_I after time tau.\nValues: A update function that determines how to update the delay channel. In this example, once the delay reaction is triggered, the first delay channel (which is the channel for X_I) will be added to a delay time tau.\ndelay_interrupt\nKeys: Indices of reactions defined in Markovian part that can cause the change in the delay channels. In this example, the 4th reaction gamma  X_I rightarrow emptyset will change the scheduled delay reaction channel immediately.\nValues: A update function that determines how to update the delay channel. In this example, once a delay_interrupt reaction happens, one randomly picked reactant X_I (supposed to leave the system after time tau) is degraded immediately.\ndelay_complete\nKeys: Indices of delay channels. Here the first delay channel corresponds to X_I.\nValues: A vector of Pairs, mapping species index to net change of stoichiometric coefficient. Here the second species X_I has a net change of -1 upon delay completion.","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Next, we choose a delay SSA algorithm and define the problem","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"de_chan0 = [[]]\ndjprob = DelayJumpProblem(\n    jumpsys, dprob, aggregatoralgo, delaysets, de_chan0; save_positions=(false, false)\n)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"where de_chan0 is the initial condition for the delay channel, which is a vector of arrays whose kth entry stores the scheduled delay time for kth delay channel. Here we assume X_I(0) = 0, thus only an empty array.","category":"page"},{"location":"tutorials/delay_degradation/#Visualization","page":"A birth-death example with delay degradation","title":"Visualization","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Now we can solve the problem and plot a trajectory","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"sol = solve(djprob, SSAStepper(); seed=2, saveat=0.1)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"(Image: degradation1)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Then we simulate 10^4 trajectories and calculate the evolution of the mean value for each reactant","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"using DiffEqBase\nens_prob = EnsembleProblem(djprob)\nens = @time solve(ens_prob, SSAStepper(), EnsembleThreads(), trajectories=1e4, saveat=0.1)","category":"page"},{"location":"tutorials/delay_degradation/#Verification-with-the-exact-solution","page":"A birth-death example with delay degradation","title":"Verification with the exact solution","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"We compare with the mean values of the exact solutions X_I X_A","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"timestamps = 0:0.1:tf\na = β + γ\nmean_x_A(t) = C / a * (1 - exp(-a * t))\nfunction mean_x_I(t)\n    return if 0 <= t <= τ\n        C * β / (a - γ) * ((1 - exp(-γ * t)) / γ - (1 - exp(-a * t)) / a)\n    else\n        C * β / a * ((1 - exp(-γ * τ)) / γ + exp(-a * t) * (1 - exp((a - γ)τ)) / (a - γ))\n    end\nend","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"(Image: degradation2)","category":"page"},{"location":"tutorials/delay_degradation/#A-multiple-delay-reaction-example","page":"A birth-death example with delay degradation","title":"A multiple delay reaction example","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"We can also extend the model to include multiple delay reactions, i.e. multiple delay channels having simultaneous delay reactions","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"beginaligned\nemptyset xrightarrowC X_A\nX_A xrightarrowgamma emptyset\nX_A xrightarrowbeta  X_I_1+X_I_2 text which triggers   X_I_1 X_I_2Rightarrow emptyset text after delay  tau\nX_I_1 xrightarrowgamma emptyset\nX_I_2 xrightarrowgamma emptyset\nendaligned","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"The 4th and 5th reactions will cause the delay channel to change its state during a scheduled delay reaction.","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Similarly, we define the problem as follows:","category":"page"},{"location":"tutorials/delay_degradation/#Markovian-part-2","page":"A birth-death example with delay degradation","title":"Markovian part","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"rn = @reaction_network begin\n    C, 0 --> Xₐ\n    γ, Xₐ --> 0\n    β, Xₐ --> Xᵢ₁ + Xᵢ₂\n    γ, Xᵢ₁ --> 0\n    γ, Xᵢ₂ --> 0\nend\njumpsys = convert(JumpSystem, rn; combinatoric_ratelaws=false)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"u0 = [0, 0, 0]\ntf = 30.0\nsaveat = 0.1\ntspan = (0.0, tf)\ndprob = DiscreteProblem(u0, tspan, p)","category":"page"},{"location":"tutorials/delay_degradation/#Non-Markovian-part-2","page":"A birth-death example with delay degradation","title":"Non-Markovian part","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"τ = 15.0\ndelay_trigger_affect! = function (integrator, rng)\n    append!(integrator.de_chan[1], τ)\n    return append!(integrator.de_chan[2], τ)\nend\ndelay_trigger = Dict(3 => delay_trigger_affect!)\ndelay_complete = Dict(1 => [2 => -1], 2 => [3 => -1])\n\ndelay_affect1! = function (integrator, rng)\n    i = rand(rng, 1:length(integrator.de_chan[1]))\n    return deleteat!(integrator.de_chan[1], i)\nend\ndelay_affect2! = function (integrator, rng)\n    i = rand(rng, 1:length(integrator.de_chan[2]))\n    return deleteat!(integrator.de_chan[2], i)\nend\ndelay_interrupt = Dict(4 => delay_affect1!, 5 => delay_affect2!)\ndelayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"de_chan0 = [[], []]\ndjprob = DelayJumpProblem(\n    jumpsys, dprob, aggregatoralgo, delaysets, de_chan0; save_positions=(false, false)\n)","category":"page"},{"location":"tutorials/delay_degradation/#Visualization-2","page":"A birth-death example with delay degradation","title":"Visualization","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"ens_prob = EnsembleProblem(djprob)\nens = @time solve(ens_prob, SSAStepper(), EnsembleThreads(), trajectories=10^4, saveat=0.1)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"(Image: degradation3)","category":"page"},{"location":"tutorials/delay_degradation/#References","page":"A birth-death example with delay degradation","title":"References","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"[1] Lafuerza, Luis F., and Raul Toral. \"Exact solution of a stochastic protein dynamics model with delayed degradation.\" Physical Review E 84, no. 5 (2011): 051121. https://doi.org/10.1103/PhysRevE.84.051121","category":"page"},{"location":"algorithms/delaymnrm/#Delay-Modified-Next-Reaction-Method-Algorithm","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"","category":"section"},{"location":"algorithms/delaymnrm/#Representation-using-Poisson-processes","page":"Delay Modified Next Reaction Method Algorithm","title":"Representation using Poisson processes","text":"","category":"section"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"Let v_k, v_kin Z^N_geq 0 be the vectors representing the number of each species consumed and created in the kth reaction, respectively. Then, if N_k(t) is the number of initiations of reaction k by time t, the state of the system at time t is","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"X(t)=X(0)+sum_k=1^MN_k(t)(v^_k-v_k)","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"However, based upon the fundamental premise of stochastic chemical kinetics, N_k(t) is a counting process with intensity a_k(X(t)) such that textP(N_k(t+Delta t)-N_k(t)=1X(s)sleqslant t)=a_k(X(t))Delta t for small Delta t. Therefore, based upon the counting process interpretation, we have","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"N_k(t)=Y_kBig(int^t_0a_k(X(s))dsBig)tag1 ","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"where the Y_k are independent, unit rate Poisson processes. Thus, X(t) can be represented as the solution to the following equation:","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"X(t)=X(0)+sum_k=1^MY_kBig(int^t_0a_k(X(s))dsBig)(v_k-v_k)","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"All the randomness in the system is encapsulated in the Y_k's and has therefore been separated from the state of the system. Thus, the system only changes when one of the Y_k's changes. There are actually M + 1 relevant time frames in the system. The first time frame is the actual, or absolute time, t. However, each Poisson process Y_k brings its own time frame. Thus, if we define T_k(t)=int^t_0a_k(X(s))ds for each k, then it is relevant for us to consider Y_k(T_k(t)). We will call T_k(t) the \"internal time\" for reaction k.","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"We denote by P_k the first firing time of Y_k, in the time frame of Y_k, which is strictly larger than T_k. That is, P_k=min leftsT_kY_k(s)Y(T_k)right. The main idea of the following algorithm is that by Eq.(1) the value","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"Delta t_k=fracP_k-T_ka_k","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"gives the amount of absolute time needed until the Poisson process Y_k fires assuming that a_k remains constant. a_k does remain constant until the next reaction takes place. Therefore, a minimum of the different Delta t_k gives the time until the next reaction takes place.","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"Now we extend the above notions to the delay system. No matter whether a reaction is contained in textND, textCD, or textICD, the number of initiations at absolute time t will be given by","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"textnumber of initiations of reaction  k text by time  t = Y_kBig(int_0^t a_k(X(s) mathrmdsBig)","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"where the Y_k are independent, unit rate Poisson processes.","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"Because the initiations are still given by the firing times of independent Poisson processes. Therefore, if T_k is the current internal time of Y_k, P_k the first internal time after T_k at which Y_k fires, and the propensity function for the kth reaction channel is given by a_k, then the time until the next initiation of reaction k(assuming no other reactions initiate or complete) is still given by Delta t_k= (P_kT_k)a_k. The only change to the algorithm will be in keeping track and storing the delayed completions. To each delayed reaction channel we therefore assign a vector, s_l, that stores the completion times of that reaction in ascending order for l=1ldotsL, where L is the total number of delay channels. Thus, the time until there is a change in the state of the system, be it an initiation or a completion, will be given by:","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"Delta = minmin_kin 1ldotsMDelta t_k min_lin1ldotsLs_l(1)  t","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"where t is the current time of the system. These ideas form the heart of the Next Reaction Method [1] for systems with delays.","category":"page"},{"location":"algorithms/delaymnrm/#Algorithm","page":"Delay Modified Next Reaction Method Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"Initialize. Set the initial number of molecules of each species and set t = 0. For each k leq M, set P_k = 0 and T_k = 0, and for each delayed reaction channel set s_l = infty.\nCalculate the propensity function, a_k, for each reaction.\nGenerate M independent, uniform (01) random numbers, r_k, and set P_k = ln(1r_k).\nSet Delta t_k = (P_k  T_k)a_k.\nSet Delta = minmin_kin 1ldotsMDelta t_k min_lin1ldotsLs_l(1)  t.\nSet t = t + Delta.\nIf we chose the completion of the delayed reaction mu:\nUpdate the system based upon the completion of the reaction mu.\nDelete the first row of S_mu.\nElseif reaction mu initiated and muin textND\nUpdate the system according to reaction mu.\nElseif reaction mu initiated and muin textCD\nUpdate s_mu by inserting t + tau_mu into s_mu in the second to last position.\nElseif reaction mu initiated and muin textICD\nUpdate the system based upon the initiation of reaction mu.\nUpdate s_mu by inserting t + tau_mu into s_mu in the second to last position.\nFor each k, set T_k = T_k + a_k Delta.\nIf reaction mu initiated, let r be uniform(01) and set P_mu = P_mu + ln(1r).\nRecalculate the propensity functions, a_k.\nReturn to step 4 or quit.","category":"page"},{"location":"algorithms/delaymnrm/#References","page":"Delay Modified Next Reaction Method Algorithm","title":"References","text":"","category":"section"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"[1] David F. Anderson, \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\", The Journal of Chemical Physics 128, 109903(2008). https://doi/10.1063/1.2799998","category":"page"},{"location":"algorithms/delaydirect/#Delay-Direct-Method-Algorithm","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"","category":"section"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"The number of discarded Delta will be approximately equal to the number of delayed reactions that initiate. This follows because, other than the stored completions at the time the code terminates, every delayed completion will cause one computed Delta to be discarded. Thus, Cai [1] developed an algorithm, called the Direct Method for systems with delays, in which no random variables are discarded.","category":"page"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"The principle of Direct Method is the same as that of the original Gillespie Algorithm and the Rejection Method above: use one random variable to calculate when the next reaction initiates and use another random variable to calculate which reaction occurs at that future time. However, Direct Method updates the state of the system and propensity functions due to stored delayed reactions during the search for the next initiation time. In this way it is ensured that no random variables are discarded as in the Rejection Method.","category":"page"},{"location":"algorithms/delaydirect/#Algorithm","page":"Delay Direct Method Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"Suppose that at time t there are ongoing delayed reactions set to complete at times t+T_1 t+T_2 ldots t+T_d. Define T_0=0 and T_d+1=infty.","category":"page"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"Define Tstruct, whose ith (i=1dotsd) row stores T_i and the index, mu_i, of the reaction that T_i is associated with.","category":"page"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"Initialize. Set the initial number of molecules of each species and set  t=0. Clear Tstruct.\nCalculate the propensity of function a_k, for each reaction k in 1ldots M.\nSet a_0=sum_k=1^Ma_k.\nGenerate  Delta.\nInput the time t and a_0=sum_k=1^Ma_k.\nGenerate an independent uniform (01) random number r_1.\nIf Tstruct is empty\nThis means there is no ongoing delay reactions, set Delta = 1a_0ln(1r_1).\nElse\nSet i=1, a_t = a_0T_1 and  F=1-e^-a_t.\nWhile F  r_1\nUpdate the state vector mathbfx due to the finish of the delayed reaction t+T_i.\nCalculate propensity a_k(t+T_i+1) due to the finish of the delayed reaction at t+T_i+1 and calculate a_0(t+T_i+1).\nUpdate a_t=a_t+a_0(t+T_i+1)(T_i+1-T_i).\nUpdate F=1-e^-a_ti=i+1.\nEndWhile\nCalculate propensity a_k(t+T_i) due to the finish of the delayed reaction at t+T_i and calculate a_0(t+T_i).\nSet Delta=T_i-(ln(1-r_1)+a_t-a_0(t+T_i)(T_i+1-T_i))a_0(t+T_i).\nEndIf\nIf DeltainT_iT_i+1), delete the columns 1ldotsi of T_i and set T_j=T_j-Delta.\nGenerate an independent uniform (01) random number r_2.\nFind muin1dotsm such that\nsum_k=1^mu-1 a_k  r_2 leq sum_k=1^mua_k\nwhere the a_k and a_0 are generated in step 4.\nIf muin textND , update the number of each molecular species according to the reaction mu.\nIf muin textCD, update Tstruct by adding the row tau_mumu so that Tstruct(i1)Tstruct(i+11) still holds for all i.\nIf muin textICD, update the system according to the initiation of mu and update Tstruct by adding the row tau_mumu so that Tstruct(i1)Tstruct(i+11) still holds for all i.\nSet t=t+Delta.\nReturn to Step 2 or quit.","category":"page"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"Remark. Notice that in the above pseudocode, we modified the Step 4 in the original algorithm for computational efficiency, but both are equivalent.","category":"page"},{"location":"algorithms/delaydirect/#References","page":"Delay Direct Method Algorithm","title":"References","text":"","category":"section"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"[1] Xiaodong Cai, \"Exact stochastic simulation of coupled chemical reactions with delays\", The Journal of Chemical Physics 126, 124108(2007). https://doi/10.1063/1.2710253","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DelaySSAToolkit","category":"page"},{"location":"#DelaySSAToolkit_doc","page":"Home","title":"DelaySSAToolkit","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A major assumption behind the majority of stochastic models of biochemical kinetics is the memoryless hypothesis, i.e., the stochastic dynamics of the reactants is only influenced by the current state of the system, which implies that the waiting times for reaction events obey exponential distributions. Gillespie developed a stochastic simulation algorithm (SSA) to simulate stochastic dynamics for such systems [1].  While this Markovian assumption considerably simplifies model analysis, it is dubious for modelling certain non-elementary reaction events that encapsulate multiple intermediate reaction steps [2]. To simulate such problems, several exact SSA methods for chemical reaction systems with delays (also known as delay SSA) were proposed [3-5].","category":"page"},{"location":"","page":"Home","title":"Home","text":"DelaySSAToolkit.jl is a tool developed on top of JumpProcesses.jl which solves the stochastic simulation with delay and contains the following features:","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Various exact delay stochastic simulation algorithms are integrated;\nStochastic delay type is supported;\nMultiple delay channels and simultaneous delay reactions are supported;\nA cascade of delay reactions is supported (a delay reaction that causes other delay reactions);\nPriority queue and dependency graph are integrated for high computational performance;\nEcosystem with Catalyst, JumpProcesses, DifferentialEquations and more...","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DelaySSAToolkit can be installed through the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"DelaySSAToolkit\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"and you might need to run","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.instantiate()","category":"page"},{"location":"","page":"Home","title":"Home","text":"for the first time after installation. To run the examples in the Tutorials section, Catalyst.jl has to be installed by","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"Catalyst\")","category":"page"},{"location":"#Recommendation","page":"Home","title":"Recommendation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To solve a DelayJumpProblem, here are few recommendations for good performance:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use Catalyst.jl to build your Markovian model (model without delays). For certain algorithms that need dependency graph, it will be auto-generated. Otherwise you must explicitly construct and pass these mappings in JumpSet (see Jump Problems for details).\nFor a few number of jumps, DelayRejection and DelayDirect will often perform better than other aggregators.\nFor large numbers of jumps with sparse chain like structures and similar jump rates, for example continuous time random walks, DelayDirectCR and DelayMNRM often have the best performance.","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Special thanks to Augustinas Sukys for his suggestions and tests on this package!","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Daniel T. Gillespie, \"Exact stochastic simulation of coupled chemical reactions\", The Journal of Physical Chemistry 1977 81 (25), 2340-2361. https://doi.org/10.1021/j100540a008","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] Qingchao Jiang, Xiaoming Fu, Shifu Yan, Runlai Li, Wenli Du, Zhixing Cao, Feng Qian, Ramon Grima, \"Neural network aided approximation and parameter inference of non-Markovian models of gene expression\". Nature communications, (2021) 12(1), 1-12. https://doi.org/10.1038/s41467-021-22919-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3] Barrio, Manuel, Kevin Burrage, André Leier, and Tianhai Tian. \"Oscillatory regulation of Hes1: discrete stochastic delay modelling and simulation.\" PLoS computational biology 2, no. 9 (2006): e117. https://doi.org/10.1371/journal.pcbi.0020117","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4] Xiaodong Cai, \"Exact stochastic simulation of coupled chemical reactions with delays\", The Journal of Chemical Physics 126, 124108(2007). https://doi/10.1063/1.2710253","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5] David F. Anderson, \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\", The Journal of Chemical Physics 128, 109903(2008). https://doi/10.1063/1.2799998","category":"page"}]
}
